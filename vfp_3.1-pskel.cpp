// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "vfp_3.1-pskel.hxx"

namespace vfp
{
  // coordinateType_pskel
  //

  void coordinateType_pskel::
  x_parser (::vfp::coordinateAttrType_pskel& p)
  {
    this->x_parser_ = &p;
  }

  void coordinateType_pskel::
  y_parser (::vfp::coordinateAttrType_pskel& p)
  {
    this->y_parser_ = &p;
  }

  void coordinateType_pskel::
  z_parser (::vfp::coordinateAttrType_pskel& p)
  {
    this->z_parser_ = &p;
  }

  void coordinateType_pskel::
  parsers (::vfp::coordinateAttrType_pskel& x,
           ::vfp::coordinateAttrType_pskel& y,
           ::vfp::coordinateAttrType_pskel& z)
  {
    this->x_parser_ = &x;
    this->y_parser_ = &y;
    this->z_parser_ = &z;
  }

  coordinateType_pskel::
  coordinateType_pskel ()
  : x_parser_ (0),
    y_parser_ (0),
    z_parser_ (0)
  {
  }

  // linpol_pskel
  //

  void linpol_pskel::
  segment_parser (::vfp::segmentType_pskel& p)
  {
    this->segment_parser_ = &p;
  }

  void linpol_pskel::
  parsers (::vfp::segmentType_pskel& segment)
  {
    this->segment_parser_ = &segment;
  }

  linpol_pskel::
  linpol_pskel ()
  : segment_parser_ (0)
  {
  }

  // linearType_pskel
  //

  void linearType_pskel::
  segment_parser (::vfp::segmentType_pskel& p)
  {
    this->segment_parser_ = &p;
  }

  void linearType_pskel::
  parsers (::vfp::segmentType_pskel& segment)
  {
    this->segment_parser_ = &segment;
  }

  linearType_pskel::
  linearType_pskel ()
  : segment_parser_ (0)
  {
  }

  // circle_pskel
  //

  void circle_pskel::
  c_parser (::vfp::coordinateType_pskel& p)
  {
    this->c_parser_ = &p;
  }

  void circle_pskel::
  r_parser (::vfp::radiusAttrType_pskel& p)
  {
    this->r_parser_ = &p;
  }

  void circle_pskel::
  parsers (::vfp::coordinateType_pskel& c,
           ::vfp::radiusAttrType_pskel& r)
  {
    this->c_parser_ = &c;
    this->r_parser_ = &r;
  }

  circle_pskel::
  circle_pskel ()
  : c_parser_ (0),
    r_parser_ (0)
  {
  }

  // solidType_pskel
  //

  void solidType_pskel::
  polygon_parser (::vfp::polygonType_pskel& p)
  {
    this->polygon_parser_ = &p;
  }

  void solidType_pskel::
  parsers (::vfp::polygonType_pskel& polygon)
  {
    this->polygon_parser_ = &polygon;
  }

  solidType_pskel::
  solidType_pskel ()
  : polygon_parser_ (0)
  {
  }

  // holeCollectionType_pskel
  //

  void holeCollectionType_pskel::
  polygon_parser (::vfp::polygonType_pskel& p)
  {
    this->polygon_parser_ = &p;
  }

  void holeCollectionType_pskel::
  parsers (::vfp::polygonType_pskel& polygon)
  {
    this->polygon_parser_ = &polygon;
  }

  holeCollectionType_pskel::
  holeCollectionType_pskel ()
  : polygon_parser_ (0)
  {
  }

  // regionType_pskel
  //

  void regionType_pskel::
  solid_parser (::vfp::solidType_pskel& p)
  {
    this->solid_parser_ = &p;
  }

  void regionType_pskel::
  holes_parser (::vfp::holeCollectionType_pskel& p)
  {
    this->holes_parser_ = &p;
  }

  void regionType_pskel::
  parsers (::vfp::solidType_pskel& solid,
           ::vfp::holeCollectionType_pskel& holes)
  {
    this->solid_parser_ = &solid;
    this->holes_parser_ = &holes;
  }

  regionType_pskel::
  regionType_pskel ()
  : solid_parser_ (0),
    holes_parser_ (0)
  {
  }

  // se_pskel
  //

  void se_pskel::
  c_parser (::vfp::coordinateType_pskel& p)
  {
    this->c_parser_ = &p;
  }

  void se_pskel::
  parsers (::vfp::coordinateType_pskel& c)
  {
    this->c_parser_ = &c;
  }

  se_pskel::
  se_pskel ()
  : c_parser_ (0)
  {
  }

  // ar_pskel
  //

  void ar_pskel::
  c_parser (::vfp::coordinateType_pskel& p)
  {
    this->c_parser_ = &p;
  }

  void ar_pskel::
  parsers (::vfp::coordinateType_pskel& c)
  {
    this->c_parser_ = &c;
  }

  ar_pskel::
  ar_pskel ()
  : c_parser_ (0)
  {
  }

  // textType_pskel
  //

  void textType_pskel::
  c_parser (::vfp::coordinateType_pskel& p)
  {
    this->c_parser_ = &p;
  }

  void textType_pskel::
  hod_parser (::vfp::notEmptyStringType_pskel& p)
  {
    this->hod_parser_ = &p;
  }

  void textType_pskel::
  o_parser (::vfp::rotationAttrType_pskel& p)
  {
    this->o_parser_ = &p;
  }

  void textType_pskel::
  j_parser (::vfp::justificationAttrType_pskel& p)
  {
    this->j_parser_ = &p;
  }

  void textType_pskel::
  vys_parser (::vfp::heightAttrType_pskel& p)
  {
    this->vys_parser_ = &p;
  }

  void textType_pskel::
  sir_parser (::vfp::widthAttrType_pskel& p)
  {
    this->sir_parser_ = &p;
  }

  void textType_pskel::
  parsers (::vfp::coordinateType_pskel& c,
           ::vfp::notEmptyStringType_pskel& hod,
           ::vfp::rotationAttrType_pskel& o,
           ::vfp::justificationAttrType_pskel& j,
           ::vfp::heightAttrType_pskel& vys,
           ::vfp::widthAttrType_pskel& sir)
  {
    this->c_parser_ = &c;
    this->hod_parser_ = &hod;
    this->o_parser_ = &o;
    this->j_parser_ = &j;
    this->vys_parser_ = &vys;
    this->sir_parser_ = &sir;
  }

  textType_pskel::
  textType_pskel ()
  : c_parser_ (0),
    hod_parser_ (0),
    o_parser_ (0),
    j_parser_ (0),
    vys_parser_ (0),
    sir_parser_ (0)
  {
  }

  // cellType_pskel
  //

  void cellType_pskel::
  c_parser (::vfp::coordinateType_pskel& p)
  {
    this->c_parser_ = &p;
  }

  void cellType_pskel::
  o_parser (::vfp::rotationAttrType_pskel& p)
  {
    this->o_parser_ = &p;
  }

  void cellType_pskel::
  naz_parser (::vfp::notEmptyStringType_pskel& p)
  {
    this->naz_parser_ = &p;
  }

  void cellType_pskel::
  parsers (::vfp::coordinateType_pskel& c,
           ::vfp::rotationAttrType_pskel& o,
           ::vfp::notEmptyStringType_pskel& naz)
  {
    this->c_parser_ = &c;
    this->o_parser_ = &o;
    this->naz_parser_ = &naz;
  }

  cellType_pskel::
  cellType_pskel ()
  : c_parser_ (0),
    o_parser_ (0),
    naz_parser_ (0)
  {
  }

  // outsideParcelType_pskel
  //

  void outsideParcelType_pskel::
  pa_parser (::vfp::pa_pskel& p)
  {
    this->pa_parser_ = &p;
  }

  void outsideParcelType_pskel::
  parsers (::vfp::pa_pskel& pa)
  {
    this->pa_parser_ = &pa;
  }

  outsideParcelType_pskel::
  outsideParcelType_pskel ()
  : pa_parser_ (0)
  {
  }

  // newNumberType_pskel
  //

  void newNumberType_pskel::
  vym_parser (::vfp::areaAttrType_pskel& p)
  {
    this->vym_parser_ = &p;
  }

  void newNumberType_pskel::
  kk_parser (::vfp::cadasterCodeType_pskel& p)
  {
    this->kk_parser_ = &p;
  }

  void newNumberType_pskel::
  kcp_parser (::vfp::parcelNumberAttrType_pskel& p)
  {
    this->kcp_parser_ = &p;
  }

  void newNumberType_pskel::
  pcp_parser (::vfp::poddeleniNumberAttrType_pskel& p)
  {
    this->pcp_parser_ = &p;
  }

  void newNumberType_pskel::
  dcp_parser (::vfp::druhCislovaniNumberAttrType_pskel& p)
  {
    this->dcp_parser_ = &p;
  }

  void newNumberType_pskel::
  parsers (::vfp::areaAttrType_pskel& vym,
           ::vfp::cadasterCodeType_pskel& kk,
           ::vfp::parcelNumberAttrType_pskel& kcp,
           ::vfp::poddeleniNumberAttrType_pskel& pcp,
           ::vfp::druhCislovaniNumberAttrType_pskel& dcp)
  {
    this->vym_parser_ = &vym;
    this->kk_parser_ = &kk;
    this->kcp_parser_ = &kcp;
    this->pcp_parser_ = &pcp;
    this->dcp_parser_ = &dcp;
  }

  newNumberType_pskel::
  newNumberType_pskel ()
  : vym_parser_ (0),
    kk_parser_ (0),
    kcp_parser_ (0),
    pcp_parser_ (0),
    dcp_parser_ (0)
  {
  }

  // newNumberCollectionType_pskel
  //

  void newNumberCollectionType_pskel::
  nc_parser (::vfp::newNumberType_pskel& p)
  {
    this->nc_parser_ = &p;
  }

  void newNumberCollectionType_pskel::
  parsers (::vfp::newNumberType_pskel& nc)
  {
    this->nc_parser_ = &nc;
  }

  newNumberCollectionType_pskel::
  newNumberCollectionType_pskel ()
  : nc_parser_ (0)
  {
  }

  // pneresType_pskel
  //

  void pneresType_pskel::
  pa_parser (::vfp::pa1_pskel& p)
  {
    this->pa_parser_ = &p;
  }

  void pneresType_pskel::
  parsers (::vfp::pa1_pskel& pa)
  {
    this->pa_parser_ = &pa;
  }

  pneresType_pskel::
  pneresType_pskel ()
  : pa_parser_ (0)
  {
  }

  // ochrType_pskel
  //

  void ochrType_pskel::
  dil_parser (::vfp::dil_pskel& p)
  {
    this->dil_parser_ = &p;
  }

  void ochrType_pskel::
  parsers (::vfp::dil_pskel& dil)
  {
    this->dil_parser_ = &dil;
  }

  ochrType_pskel::
  ochrType_pskel ()
  : dil_parser_ (0)
  {
  }

  // bremenoType_pskel
  //

  void bremenoType_pskel::
  cen_parser (::vfp::priceAttrType_pskel& p)
  {
    this->cen_parser_ = &p;
  }

  void bremenoType_pskel::
  typ_parser (::vfp::typPravAttrType_pskel& p)
  {
    this->typ_parser_ = &p;
  }

  void bremenoType_pskel::
  popis_parser (::vfp::notEmptyStringType_pskel& p)
  {
    this->popis_parser_ = &p;
  }

  void bremenoType_pskel::
  o_pro_id_parser (::vfp::notEmptyStringType_pskel& p)
  {
    this->o_pro_id_parser_ = &p;
  }

  void bremenoType_pskel::
  p_k_id_parser (::vfp::notEmptyStringType_pskel& p)
  {
    this->p_k_id_parser_ = &p;
  }

  void bremenoType_pskel::
  o_k_id_parser (::vfp::notEmptyStringType_pskel& p)
  {
    this->o_k_id_parser_ = &p;
  }

  void bremenoType_pskel::
  pn_id_parser (::vfp::parcelIdAttrType_pskel& p)
  {
    this->pn_id_parser_ = &p;
  }

  void bremenoType_pskel::
  p_pro_id_parser (::vfp::parcelIdAttrType_pskel& p)
  {
    this->p_pro_id_parser_ = &p;
  }

  void bremenoType_pskel::
  parsers (::vfp::priceAttrType_pskel& cen,
           ::vfp::typPravAttrType_pskel& typ,
           ::vfp::notEmptyStringType_pskel& popis,
           ::vfp::notEmptyStringType_pskel& o_pro_id,
           ::vfp::notEmptyStringType_pskel& p_k_id,
           ::vfp::notEmptyStringType_pskel& o_k_id,
           ::vfp::parcelIdAttrType_pskel& pn_id,
           ::vfp::parcelIdAttrType_pskel& p_pro_id)
  {
    this->cen_parser_ = &cen;
    this->typ_parser_ = &typ;
    this->popis_parser_ = &popis;
    this->o_pro_id_parser_ = &o_pro_id;
    this->p_k_id_parser_ = &p_k_id;
    this->o_k_id_parser_ = &o_k_id;
    this->pn_id_parser_ = &pn_id;
    this->p_pro_id_parser_ = &p_pro_id;
  }

  bremenoType_pskel::
  bremenoType_pskel ()
  : cen_parser_ (0),
    typ_parser_ (0),
    popis_parser_ (0),
    o_pro_id_parser_ (0),
    p_k_id_parser_ (0),
    o_k_id_parser_ (0),
    pn_id_parser_ (0),
    p_pro_id_parser_ (0)
  {
  }

  // bremCollectionType_pskel
  //

  void bremCollectionType_pskel::
  bre_parser (::vfp::bremenoType_pskel& p)
  {
    this->bre_parser_ = &p;
  }

  void bremCollectionType_pskel::
  parsers (::vfp::bremenoType_pskel& bre)
  {
    this->bre_parser_ = &bre;
  }

  bremCollectionType_pskel::
  bremCollectionType_pskel ()
  : bre_parser_ (0)
  {
  }

  // nvlaType_pskel
  //

  void nvlaType_pskel::
  lvn_parser (::vfp::lvNumberAttrType_pskel& p)
  {
    this->lvn_parser_ = &p;
  }

  void nvlaType_pskel::
  kkn_parser (::vfp::cadasterCodeType_pskel& p)
  {
    this->kkn_parser_ = &p;
  }

  void nvlaType_pskel::
  vymp_parser (::vfp::areaAttrType_pskel& p)
  {
    this->vymp_parser_ = &p;
  }

  void nvlaType_pskel::
  cenp_parser (::vfp::priceAttrType_pskel& p)
  {
    this->cenp_parser_ = &p;
  }

  void nvlaType_pskel::
  vzdp_parser (::vfp::distanceType_pskel& p)
  {
    this->vzdp_parser_ = &p;
  }

  void nvlaType_pskel::
  op_id_parser (::vfp::opsubIdType_pskel& p)
  {
    this->op_id_parser_ = &p;
  }

  void nvlaType_pskel::
  poz_parser (::vfp::noteAttrType_pskel& p)
  {
    this->poz_parser_ = &p;
  }

  void nvlaType_pskel::
  parsers (::vfp::lvNumberAttrType_pskel& lvn,
           ::vfp::cadasterCodeType_pskel& kkn,
           ::vfp::areaAttrType_pskel& vymp,
           ::vfp::priceAttrType_pskel& cenp,
           ::vfp::distanceType_pskel& vzdp,
           ::vfp::opsubIdType_pskel& op_id,
           ::vfp::noteAttrType_pskel& poz)
  {
    this->lvn_parser_ = &lvn;
    this->kkn_parser_ = &kkn;
    this->vymp_parser_ = &vymp;
    this->cenp_parser_ = &cenp;
    this->vzdp_parser_ = &vzdp;
    this->op_id_parser_ = &op_id;
    this->poz_parser_ = &poz;
  }

  nvlaType_pskel::
  nvlaType_pskel ()
  : lvn_parser_ (0),
    kkn_parser_ (0),
    vymp_parser_ (0),
    cenp_parser_ (0),
    vzdp_parser_ (0),
    op_id_parser_ (0),
    poz_parser_ (0)
  {
  }

  // nvlaCollectionType_pskel
  //

  void nvlaCollectionType_pskel::
  nvla_parser (::vfp::nvlaType_pskel& p)
  {
    this->nvla_parser_ = &p;
  }

  void nvlaCollectionType_pskel::
  parsers (::vfp::nvlaType_pskel& nvla)
  {
    this->nvla_parser_ = &nvla;
  }

  nvlaCollectionType_pskel::
  nvlaCollectionType_pskel ()
  : nvla_parser_ (0)
  {
  }

  // vlaCollectionType_pskel
  //

  void vlaCollectionType_pskel::
  vla_parser (::vfp::vla_pskel& p)
  {
    this->vla_parser_ = &p;
  }

  void vlaCollectionType_pskel::
  parsers (::vfp::vla_pskel& vla)
  {
    this->vla_parser_ = &vla;
  }

  vlaCollectionType_pskel::
  vlaCollectionType_pskel ()
  : vla_parser_ (0)
  {
  }

  // participantReferenceType_pskel
  //

  void participantReferenceType_pskel::
  uc_id_parser (::vfp::participantIdAttrType_pskel& p)
  {
    this->uc_id_parser_ = &p;
  }

  void participantReferenceType_pskel::
  op_id_parser (::vfp::opsubIdType_pskel& p)
  {
    this->op_id_parser_ = &p;
  }

  void participantReferenceType_pskel::
  typ_parser (::vfp::participantType_pskel& p)
  {
    this->typ_parser_ = &p;
  }

  void participantReferenceType_pskel::
  parsers (::vfp::participantIdAttrType_pskel& uc_id,
           ::vfp::opsubIdType_pskel& op_id,
           ::vfp::participantType_pskel& typ)
  {
    this->uc_id_parser_ = &uc_id;
    this->op_id_parser_ = &op_id;
    this->typ_parser_ = &typ;
  }

  participantReferenceType_pskel::
  participantReferenceType_pskel ()
  : uc_id_parser_ (0),
    op_id_parser_ (0),
    typ_parser_ (0)
  {
  }

  // navrhType_pskel
  //

  void navrhType_pskel::
  lv_parser (::vfp::lv_pskel& p)
  {
    this->lv_parser_ = &p;
  }

  void navrhType_pskel::
  fn_parser (::vfp::navrhPhaseType_pskel& p)
  {
    this->fn_parser_ = &p;
  }

  void navrhType_pskel::
  dvn_parser (::xml_schema::date_time_pskel& p)
  {
    this->dvn_parser_ = &p;
  }

  void navrhType_pskel::
  dvnr_parser (::xml_schema::date_time_pskel& p)
  {
    this->dvnr_parser_ = &p;
  }

  void navrhType_pskel::
  parsers (::vfp::lv_pskel& lv,
           ::vfp::navrhPhaseType_pskel& fn,
           ::xml_schema::date_time_pskel& dvn,
           ::xml_schema::date_time_pskel& dvnr)
  {
    this->lv_parser_ = &lv;
    this->fn_parser_ = &fn;
    this->dvn_parser_ = &dvn;
    this->dvnr_parser_ = &dvnr;
  }

  navrhType_pskel::
  navrhType_pskel ()
  : lv_parser_ (0),
    fn_parser_ (0),
    dvn_parser_ (0),
    dvnr_parser_ (0)
  {
  }

  // bpejCollectionType_pskel
  //

  void bpejCollectionType_pskel::
  dil_parser (::vfp::dil1_pskel& p)
  {
    this->dil_parser_ = &p;
  }

  void bpejCollectionType_pskel::
  parsers (::vfp::dil1_pskel& dil)
  {
    this->dil_parser_ = &dil;
  }

  bpejCollectionType_pskel::
  bpejCollectionType_pskel ()
  : dil_parser_ (0)
  {
  }

  // claimBpejCollectionType_pskel
  //

  void claimBpejCollectionType_pskel::
  dil_parser (::vfp::dil2_pskel& p)
  {
    this->dil_parser_ = &p;
  }

  void claimBpejCollectionType_pskel::
  parsers (::vfp::dil2_pskel& dil)
  {
    this->dil_parser_ = &dil;
  }

  claimBpejCollectionType_pskel::
  claimBpejCollectionType_pskel ()
  : dil_parser_ (0)
  {
  }

  // solPart_pskel
  //

  void solPart_pskel::
  cen_parser (::vfp::priceAttrType_pskel& p)
  {
    this->cen_parser_ = &p;
  }

  void solPart_pskel::
  naz_parser (::vfp::notEmptyStringType_pskel& p)
  {
    this->naz_parser_ = &p;
  }

  void solPart_pskel::
  parsers (::vfp::priceAttrType_pskel& cen,
           ::vfp::notEmptyStringType_pskel& naz)
  {
    this->cen_parser_ = &cen;
    this->naz_parser_ = &naz;
  }

  solPart_pskel::
  solPart_pskel ()
  : cen_parser_ (0),
    naz_parser_ (0)
  {
  }

  // znaPart_pskel
  //

  void znaPart_pskel::
  cen_parser (::vfp::areaAttrType_pskel& p)
  {
    this->cen_parser_ = &p;
  }

  void znaPart_pskel::
  parsers (::vfp::areaAttrType_pskel& cen)
  {
    this->cen_parser_ = &cen;
  }

  znaPart_pskel::
  znaPart_pskel ()
  : cen_parser_ (0)
  {
  }

  // porPart_pskel
  //

  void porPart_pskel::
  dp_parser (::vfp::kindOfAreaAttrType_pskel& p)
  {
    this->dp_parser_ = &p;
  }

  void porPart_pskel::
  dpo_parser (::vfp::areaKindLabelAttrType_pskel& p)
  {
    this->dpo_parser_ = &p;
  }

  void porPart_pskel::
  zv_parser (::vfp::kindOfUseAttrType_pskel& p)
  {
    this->zv_parser_ = &p;
  }

  void porPart_pskel::
  cen_parser (::vfp::priceAttrType_pskel& p)
  {
    this->cen_parser_ = &p;
  }

  void porPart_pskel::
  vym_parser (::vfp::areaAttrType_pskel& p)
  {
    this->vym_parser_ = &p;
  }

  void porPart_pskel::
  parsers (::vfp::kindOfAreaAttrType_pskel& dp,
           ::vfp::areaKindLabelAttrType_pskel& dpo,
           ::vfp::kindOfUseAttrType_pskel& zv,
           ::vfp::priceAttrType_pskel& cen,
           ::vfp::areaAttrType_pskel& vym)
  {
    this->dp_parser_ = &dp;
    this->dpo_parser_ = &dpo;
    this->zv_parser_ = &zv;
    this->cen_parser_ = &cen;
    this->vym_parser_ = &vym;
  }

  porPart_pskel::
  porPart_pskel ()
  : dp_parser_ (0),
    dpo_parser_ (0),
    zv_parser_ (0),
    cen_parser_ (0),
    vym_parser_ (0)
  {
  }

  // porCollectionType_pskel
  //

  void porCollectionType_pskel::
  dil_parser (::vfp::porostPartTypeBase_pskel& p)
  {
    this->dil_parser_ = &p;
  }

  void porCollectionType_pskel::
  parsers (::vfp::porostPartTypeBase_pskel& dil)
  {
    this->dil_parser_ = &dil;
  }

  porCollectionType_pskel::
  porCollectionType_pskel ()
  : dil_parser_ (0)
  {
  }

  // areaType_pskel
  //

  void areaType_pskel::
  reg_parser (::vfp::regionType_pskel& p)
  {
    this->reg_parser_ = &p;
  }

  void areaType_pskel::
  t_parser (::vfp::textType_pskel& p)
  {
    this->t_parser_ = &p;
  }

  void areaType_pskel::
  parsers (::vfp::regionType_pskel& reg,
           ::vfp::textType_pskel& t)
  {
    this->reg_parser_ = &reg;
    this->t_parser_ = &t;
  }

  areaType_pskel::
  areaType_pskel ()
  : reg_parser_ (0),
    t_parser_ (0)
  {
  }

  // ucaCollectionType_pskel
  //

  void ucaCollectionType_pskel::
  uca_parser (::vfp::participantReferenceType_pskel& p)
  {
    this->uca_parser_ = &p;
  }

  void ucaCollectionType_pskel::
  parsers (::vfp::participantReferenceType_pskel& uca)
  {
    this->uca_parser_ = &uca;
  }

  ucaCollectionType_pskel::
  ucaCollectionType_pskel ()
  : uca_parser_ (0)
  {
  }

  // gparType_pskel
  //

  void gparType_pskel::
  area_parser (::vfp::areaType_pskel& p)
  {
    this->area_parser_ = &p;
  }

  void gparType_pskel::
  parsers (::vfp::areaType_pskel& area)
  {
    this->area_parser_ = &area;
  }

  gparType_pskel::
  gparType_pskel ()
  : area_parser_ (0)
  {
  }

  // narokType_pskel
  //

  void narokType_pskel::
  lv_parser (::vfp::lv1_pskel& p)
  {
    this->lv_parser_ = &p;
  }

  void narokType_pskel::
  parsers (::vfp::lv1_pskel& lv)
  {
    this->lv_parser_ = &lv;
  }

  narokType_pskel::
  narokType_pskel ()
  : lv_parser_ (0)
  {
  }

  // ucaType_pskel
  //

  void ucaType_pskel::
  id_parser (::vfp::participantIdAttrType_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void ucaType_pskel::
  op_id_parser (::vfp::opsubIdType_pskel& p)
  {
    this->op_id_parser_ = &p;
  }

  void ucaType_pskel::
  jm_parser (::xml_schema::string_pskel& p)
  {
    this->jm_parser_ = &p;
  }

  void ucaType_pskel::
  pr_parser (::xml_schema::string_pskel& p)
  {
    this->pr_parser_ = &p;
  }

  void ucaType_pskel::
  naz_parser (::xml_schema::string_pskel& p)
  {
    this->naz_parser_ = &p;
  }

  void ucaType_pskel::
  tpj_parser (::xml_schema::string_pskel& p)
  {
    this->tpj_parser_ = &p;
  }

  void ucaType_pskel::
  tzj_parser (::xml_schema::string_pskel& p)
  {
    this->tzj_parser_ = &p;
  }

  void ucaType_pskel::
  rc_parser (::vfp::birthNumberType_pskel& p)
  {
    this->rc_parser_ = &p;
  }

  void ucaType_pskel::
  ico_parser (::vfp::icoType_pskel& p)
  {
    this->ico_parser_ = &p;
  }

  void ucaType_pskel::
  ul_parser (::xml_schema::string_pskel& p)
  {
    this->ul_parser_ = &p;
  }

  void ucaType_pskel::
  cd_parser (::vfp::streetNumberType_pskel& p)
  {
    this->cd_parser_ = &p;
  }

  void ucaType_pskel::
  co_parser (::vfp::orientationNumberType_pskel& p)
  {
    this->co_parser_ = &p;
  }

  void ucaType_pskel::
  caob_parser (::xml_schema::string_pskel& p)
  {
    this->caob_parser_ = &p;
  }

  void ucaType_pskel::
  mc_parser (::xml_schema::string_pskel& p)
  {
    this->mc_parser_ = &p;
  }

  void ucaType_pskel::
  ob_parser (::xml_schema::string_pskel& p)
  {
    this->ob_parser_ = &p;
  }

  void ucaType_pskel::
  psc_parser (::vfp::postCodeType_pskel& p)
  {
    this->psc_parser_ = &p;
  }

  void ucaType_pskel::
  okr_parser (::xml_schema::string_pskel& p)
  {
    this->okr_parser_ = &p;
  }

  void ucaType_pskel::
  sta_parser (::xml_schema::string_pskel& p)
  {
    this->sta_parser_ = &p;
  }

  void ucaType_pskel::
  email_parser (::vfp::emailType_pskel& p)
  {
    this->email_parser_ = &p;
  }

  void ucaType_pskel::
  tel_parser (::vfp::notEmptyStringType_pskel& p)
  {
    this->tel_parser_ = &p;
  }

  void ucaType_pskel::
  parsers (::vfp::participantIdAttrType_pskel& id,
           ::vfp::opsubIdType_pskel& op_id,
           ::xml_schema::string_pskel& jm,
           ::xml_schema::string_pskel& pr,
           ::xml_schema::string_pskel& naz,
           ::xml_schema::string_pskel& tpj,
           ::xml_schema::string_pskel& tzj,
           ::vfp::birthNumberType_pskel& rc,
           ::vfp::icoType_pskel& ico,
           ::xml_schema::string_pskel& ul,
           ::vfp::streetNumberType_pskel& cd,
           ::vfp::orientationNumberType_pskel& co,
           ::xml_schema::string_pskel& caob,
           ::xml_schema::string_pskel& mc,
           ::xml_schema::string_pskel& ob,
           ::vfp::postCodeType_pskel& psc,
           ::xml_schema::string_pskel& okr,
           ::xml_schema::string_pskel& sta,
           ::vfp::emailType_pskel& email,
           ::vfp::notEmptyStringType_pskel& tel)
  {
    this->id_parser_ = &id;
    this->op_id_parser_ = &op_id;
    this->jm_parser_ = &jm;
    this->pr_parser_ = &pr;
    this->naz_parser_ = &naz;
    this->tpj_parser_ = &tpj;
    this->tzj_parser_ = &tzj;
    this->rc_parser_ = &rc;
    this->ico_parser_ = &ico;
    this->ul_parser_ = &ul;
    this->cd_parser_ = &cd;
    this->co_parser_ = &co;
    this->caob_parser_ = &caob;
    this->mc_parser_ = &mc;
    this->ob_parser_ = &ob;
    this->psc_parser_ = &psc;
    this->okr_parser_ = &okr;
    this->sta_parser_ = &sta;
    this->email_parser_ = &email;
    this->tel_parser_ = &tel;
  }

  ucaType_pskel::
  ucaType_pskel ()
  : id_parser_ (0),
    op_id_parser_ (0),
    jm_parser_ (0),
    pr_parser_ (0),
    naz_parser_ (0),
    tpj_parser_ (0),
    tzj_parser_ (0),
    rc_parser_ (0),
    ico_parser_ (0),
    ul_parser_ (0),
    cd_parser_ (0),
    co_parser_ (0),
    caob_parser_ (0),
    mc_parser_ (0),
    ob_parser_ (0),
    psc_parser_ (0),
    okr_parser_ (0),
    sta_parser_ (0),
    email_parser_ (0),
    tel_parser_ (0)
  {
  }

  // ucastniciType_pskel
  //

  void ucastniciType_pskel::
  uca_parser (::vfp::ucaType_pskel& p)
  {
    this->uca_parser_ = &p;
  }

  void ucastniciType_pskel::
  parsers (::vfp::ucaType_pskel& uca)
  {
    this->uca_parser_ = &uca;
  }

  ucastniciType_pskel::
  ucastniciType_pskel ()
  : uca_parser_ (0)
  {
  }

  // mdpType_pskel
  //

  void mdpType_pskel::
  pl_parser (::vfp::pl_pskel& p)
  {
    this->pl_parser_ = &p;
  }

  void mdpType_pskel::
  parsers (::vfp::pl_pskel& pl)
  {
    this->pl_parser_ = &pl;
  }

  mdpType_pskel::
  mdpType_pskel ()
  : pl_parser_ (0)
  {
  }

  // plin_pskel
  //

  void plin_pskel::
  lin_parser (::vfp::linearType_pskel& p)
  {
    this->lin_parser_ = &p;
  }

  void plin_pskel::
  typ_parser (::vfp::graphicElementCodeType_pskel& p)
  {
    this->typ_parser_ = &p;
  }

  void plin_pskel::
  parsers (::vfp::linearType_pskel& lin,
           ::vfp::graphicElementCodeType_pskel& typ)
  {
    this->lin_parser_ = &lin;
    this->typ_parser_ = &typ;
  }

  plin_pskel::
  plin_pskel ()
  : lin_parser_ (0),
    typ_parser_ (0)
  {
  }

  // pzna_pskel
  //

  void pzna_pskel::
  b_parser (::vfp::cellType_pskel& p)
  {
    this->b_parser_ = &p;
  }

  void pzna_pskel::
  typ_parser (::vfp::graphicElementCodeType_pskel& p)
  {
    this->typ_parser_ = &p;
  }

  void pzna_pskel::
  parsers (::vfp::cellType_pskel& b,
           ::vfp::graphicElementCodeType_pskel& typ)
  {
    this->b_parser_ = &b;
    this->typ_parser_ = &typ;
  }

  pzna_pskel::
  pzna_pskel ()
  : b_parser_ (0),
    typ_parser_ (0)
  {
  }

  // ptext_pskel
  //

  void ptext_pskel::
  t_parser (::vfp::textType_pskel& p)
  {
    this->t_parser_ = &p;
  }

  void ptext_pskel::
  typ_parser (::vfp::graphicElementCodeType_pskel& p)
  {
    this->typ_parser_ = &p;
  }

  void ptext_pskel::
  parsers (::vfp::textType_pskel& t,
           ::vfp::graphicElementCodeType_pskel& typ)
  {
    this->t_parser_ = &t;
    this->typ_parser_ = &typ;
  }

  ptext_pskel::
  ptext_pskel ()
  : t_parser_ (0),
    typ_parser_ (0)
  {
  }

  // parea_pskel
  //

  void parea_pskel::
  reg_parser (::vfp::regionType_pskel& p)
  {
    this->reg_parser_ = &p;
  }

  void parea_pskel::
  typ_parser (::vfp::graphicElementCodeType_pskel& p)
  {
    this->typ_parser_ = &p;
  }

  void parea_pskel::
  parsers (::vfp::regionType_pskel& reg,
           ::vfp::graphicElementCodeType_pskel& typ)
  {
    this->reg_parser_ = &reg;
    this->typ_parser_ = &typ;
  }

  parea_pskel::
  parea_pskel ()
  : reg_parser_ (0),
    typ_parser_ (0)
  {
  }

  // psouType_pskel
  //

  void psouType_pskel::
  sx_parser (::vfp::coordinateAttrType_pskel& p)
  {
    this->sx_parser_ = &p;
  }

  void psouType_pskel::
  sy_parser (::vfp::coordinateAttrType_pskel& p)
  {
    this->sy_parser_ = &p;
  }

  void psouType_pskel::
  sz_parser (::vfp::coordinateAttrType_pskel& p)
  {
    this->sz_parser_ = &p;
  }

  void psouType_pskel::
  cb_parser (::xml_schema::integer_pskel& p)
  {
    this->cb_parser_ = &p;
  }

  void psouType_pskel::
  parsers (::vfp::coordinateAttrType_pskel& sx,
           ::vfp::coordinateAttrType_pskel& sy,
           ::vfp::coordinateAttrType_pskel& sz,
           ::xml_schema::integer_pskel& cb)
  {
    this->sx_parser_ = &sx;
    this->sy_parser_ = &sy;
    this->sz_parser_ = &sz;
    this->cb_parser_ = &cb;
  }

  psouType_pskel::
  psouType_pskel ()
  : sx_parser_ (0),
    sy_parser_ (0),
    sz_parser_ (0),
    cb_parser_ (0)
  {
  }

  // zsType_pskel
  //

  void zsType_pskel::
  plins_parser (::vfp::plins_pskel& p)
  {
    this->plins_parser_ = &p;
  }

  void zsType_pskel::
  pznas_parser (::vfp::pznas_pskel& p)
  {
    this->pznas_parser_ = &p;
  }

  void zsType_pskel::
  ptexts_parser (::vfp::ptexts_pskel& p)
  {
    this->ptexts_parser_ = &p;
  }

  void zsType_pskel::
  psour_parser (::vfp::psour_pskel& p)
  {
    this->psour_parser_ = &p;
  }

  void zsType_pskel::
  parsers (::vfp::plins_pskel& plins,
           ::vfp::pznas_pskel& pznas,
           ::vfp::ptexts_pskel& ptexts,
           ::vfp::psour_pskel& psour)
  {
    this->plins_parser_ = &plins;
    this->pznas_parser_ = &pznas;
    this->ptexts_parser_ = &ptexts;
    this->psour_parser_ = &psour;
  }

  zsType_pskel::
  zsType_pskel ()
  : plins_parser_ (0),
    pznas_parser_ (0),
    ptexts_parser_ (0),
    psour_parser_ (0)
  {
  }

  // pmType_pskel
  //

  void pmType_pskel::
  pmlins_parser (::vfp::pmlins_pskel& p)
  {
    this->pmlins_parser_ = &p;
  }

  void pmType_pskel::
  pmznas_parser (::vfp::pmznas_pskel& p)
  {
    this->pmznas_parser_ = &p;
  }

  void pmType_pskel::
  pmtexts_parser (::vfp::pmtexts_pskel& p)
  {
    this->pmtexts_parser_ = &p;
  }

  void pmType_pskel::
  pmareas_parser (::vfp::pmareas_pskel& p)
  {
    this->pmareas_parser_ = &p;
  }

  void pmType_pskel::
  parsers (::vfp::pmlins_pskel& pmlins,
           ::vfp::pmznas_pskel& pmznas,
           ::vfp::pmtexts_pskel& pmtexts,
           ::vfp::pmareas_pskel& pmareas)
  {
    this->pmlins_parser_ = &pmlins;
    this->pmznas_parser_ = &pmznas;
    this->pmtexts_parser_ = &pmtexts;
    this->pmareas_parser_ = &pmareas;
  }

  pmType_pskel::
  pmType_pskel ()
  : pmlins_parser_ (0),
    pmznas_parser_ (0),
    pmtexts_parser_ (0),
    pmareas_parser_ (0)
  {
  }

  // mpType_pskel
  //

  void mpType_pskel::
  mplins_parser (::vfp::mplins_pskel& p)
  {
    this->mplins_parser_ = &p;
  }

  void mpType_pskel::
  mpznas_parser (::vfp::mpznas_pskel& p)
  {
    this->mpznas_parser_ = &p;
  }

  void mpType_pskel::
  mptexts_parser (::vfp::mptexts_pskel& p)
  {
    this->mptexts_parser_ = &p;
  }

  void mpType_pskel::
  mpareas_parser (::vfp::mpareas_pskel& p)
  {
    this->mpareas_parser_ = &p;
  }

  void mpType_pskel::
  parsers (::vfp::mplins_pskel& mplins,
           ::vfp::mpznas_pskel& mpznas,
           ::vfp::mptexts_pskel& mptexts,
           ::vfp::mpareas_pskel& mpareas)
  {
    this->mplins_parser_ = &mplins;
    this->mpznas_parser_ = &mpznas;
    this->mptexts_parser_ = &mptexts;
    this->mpareas_parser_ = &mpareas;
  }

  mpType_pskel::
  mpType_pskel ()
  : mplins_parser_ (0),
    mpznas_parser_ (0),
    mptexts_parser_ (0),
    mpareas_parser_ (0)
  {
  }

  // meosType_pskel
  //

  void meosType_pskel::
  meoslins_parser (::vfp::meoslins_pskel& p)
  {
    this->meoslins_parser_ = &p;
  }

  void meosType_pskel::
  meosznas_parser (::vfp::meosznas_pskel& p)
  {
    this->meosznas_parser_ = &p;
  }

  void meosType_pskel::
  meostexts_parser (::vfp::meostexts_pskel& p)
  {
    this->meostexts_parser_ = &p;
  }

  void meosType_pskel::
  meosareas_parser (::vfp::meosareas_pskel& p)
  {
    this->meosareas_parser_ = &p;
  }

  void meosType_pskel::
  parsers (::vfp::meoslins_pskel& meoslins,
           ::vfp::meosznas_pskel& meosznas,
           ::vfp::meostexts_pskel& meostexts,
           ::vfp::meosareas_pskel& meosareas)
  {
    this->meoslins_parser_ = &meoslins;
    this->meosznas_parser_ = &meosznas;
    this->meostexts_parser_ = &meostexts;
    this->meosareas_parser_ = &meosareas;
  }

  meosType_pskel::
  meosType_pskel ()
  : meoslins_parser_ (0),
    meosznas_parser_ (0),
    meostexts_parser_ (0),
    meosareas_parser_ (0)
  {
  }

  // meonType_pskel
  //

  void meonType_pskel::
  meonlins_parser (::vfp::meonlins_pskel& p)
  {
    this->meonlins_parser_ = &p;
  }

  void meonType_pskel::
  meonznas_parser (::vfp::meonznas_pskel& p)
  {
    this->meonznas_parser_ = &p;
  }

  void meonType_pskel::
  meontexts_parser (::vfp::meontexts_pskel& p)
  {
    this->meontexts_parser_ = &p;
  }

  void meonType_pskel::
  meonareas_parser (::vfp::meonareas_pskel& p)
  {
    this->meonareas_parser_ = &p;
  }

  void meonType_pskel::
  parsers (::vfp::meonlins_pskel& meonlins,
           ::vfp::meonznas_pskel& meonznas,
           ::vfp::meontexts_pskel& meontexts,
           ::vfp::meonareas_pskel& meonareas)
  {
    this->meonlins_parser_ = &meonlins;
    this->meonznas_parser_ = &meonznas;
    this->meontexts_parser_ = &meontexts;
    this->meonareas_parser_ = &meonareas;
  }

  meonType_pskel::
  meonType_pskel ()
  : meonlins_parser_ (0),
    meonznas_parser_ (0),
    meontexts_parser_ (0),
    meonareas_parser_ (0)
  {
  }

  // hvpszType_pskel
  //

  void hvpszType_pskel::
  hvpszlins_parser (::vfp::hvpszlins_pskel& p)
  {
    this->hvpszlins_parser_ = &p;
  }

  void hvpszType_pskel::
  hvpszznas_parser (::vfp::hvpszznas_pskel& p)
  {
    this->hvpszznas_parser_ = &p;
  }

  void hvpszType_pskel::
  hvpsztexts_parser (::vfp::hvpsztexts_pskel& p)
  {
    this->hvpsztexts_parser_ = &p;
  }

  void hvpszType_pskel::
  hvpszareas_parser (::vfp::hvpszareas_pskel& p)
  {
    this->hvpszareas_parser_ = &p;
  }

  void hvpszType_pskel::
  parsers (::vfp::hvpszlins_pskel& hvpszlins,
           ::vfp::hvpszznas_pskel& hvpszznas,
           ::vfp::hvpsztexts_pskel& hvpsztexts,
           ::vfp::hvpszareas_pskel& hvpszareas)
  {
    this->hvpszlins_parser_ = &hvpszlins;
    this->hvpszznas_parser_ = &hvpszznas;
    this->hvpsztexts_parser_ = &hvpsztexts;
    this->hvpszareas_parser_ = &hvpszareas;
  }

  hvpszType_pskel::
  hvpszType_pskel ()
  : hvpszlins_parser_ (0),
    hvpszznas_parser_ (0),
    hvpsztexts_parser_ (0),
    hvpszareas_parser_ (0)
  {
  }

  // zvbodsType_pskel
  //

  void zvbodsType_pskel::
  zvbod_parser (::vfp::zvbod_pskel& p)
  {
    this->zvbod_parser_ = &p;
  }

  void zvbodsType_pskel::
  parsers (::vfp::zvbod_pskel& zvbod)
  {
    this->zvbod_parser_ = &zvbod;
  }

  zvbodsType_pskel::
  zvbodsType_pskel ()
  : zvbod_parser_ (0)
  {
  }

  // zvlinsType_pskel
  //

  void zvlinsType_pskel::
  zvlin_parser (::vfp::zvlin_pskel& p)
  {
    this->zvlin_parser_ = &p;
  }

  void zvlinsType_pskel::
  parsers (::vfp::zvlin_pskel& zvlin)
  {
    this->zvlin_parser_ = &zvlin;
  }

  zvlinsType_pskel::
  zvlinsType_pskel ()
  : zvlin_parser_ (0)
  {
  }

  // zvareasType_pskel
  //

  void zvareasType_pskel::
  zvarea_parser (::vfp::zvarea_pskel& p)
  {
    this->zvarea_parser_ = &p;
  }

  void zvareasType_pskel::
  parsers (::vfp::zvarea_pskel& zvarea)
  {
    this->zvarea_parser_ = &zvarea;
  }

  zvareasType_pskel::
  zvareasType_pskel ()
  : zvarea_parser_ (0)
  {
  }

  // souType_pskel
  //

  void souType_pskel::
  sx_parser (::vfp::coordinateAttrType_pskel& p)
  {
    this->sx_parser_ = &p;
  }

  void souType_pskel::
  sy_parser (::vfp::coordinateAttrType_pskel& p)
  {
    this->sy_parser_ = &p;
  }

  void souType_pskel::
  cb_parser (::xml_schema::integer_pskel& p)
  {
    this->cb_parser_ = &p;
  }

  void souType_pskel::
  kk_parser (::xml_schema::integer_pskel& p)
  {
    this->kk_parser_ = &p;
  }

  void souType_pskel::
  ps_parser (::vfp::notEmptyStringType_pskel& p)
  {
    this->ps_parser_ = &p;
  }

  void souType_pskel::
  vys_parser (::vfp::vysAttrType_pskel& p)
  {
    this->vys_parser_ = &p;
  }

  void souType_pskel::
  parsers (::vfp::coordinateAttrType_pskel& sx,
           ::vfp::coordinateAttrType_pskel& sy,
           ::xml_schema::integer_pskel& cb,
           ::xml_schema::integer_pskel& kk,
           ::vfp::notEmptyStringType_pskel& ps,
           ::vfp::vysAttrType_pskel& vys)
  {
    this->sx_parser_ = &sx;
    this->sy_parser_ = &sy;
    this->cb_parser_ = &cb;
    this->kk_parser_ = &kk;
    this->ps_parser_ = &ps;
    this->vys_parser_ = &vys;
  }

  souType_pskel::
  souType_pskel ()
  : sx_parser_ (0),
    sy_parser_ (0),
    cb_parser_ (0),
    kk_parser_ (0),
    ps_parser_ (0),
    vys_parser_ (0)
  {
  }

  // opuType_pskel
  //

  void opuType_pskel::
  pl_parser (::vfp::pl1_pskel& p)
  {
    this->pl_parser_ = &p;
  }

  void opuType_pskel::
  parsers (::vfp::pl1_pskel& pl)
  {
    this->pl_parser_ = &pl;
  }

  opuType_pskel::
  opuType_pskel ()
  : pl_parser_ (0)
  {
  }

  // sol_pskel
  //

  void sol_pskel::
  b_parser (::vfp::cellType_pskel& p)
  {
    this->b_parser_ = &p;
  }

  void sol_pskel::
  cen_parser (::vfp::priceAttrType_pskel& p)
  {
    this->cen_parser_ = &p;
  }

  void sol_pskel::
  naz_parser (::xml_schema::string_pskel& p)
  {
    this->naz_parser_ = &p;
  }

  void sol_pskel::
  id_parser (::vfp::basicIdAttrType_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void sol_pskel::
  parsers (::vfp::cellType_pskel& b,
           ::vfp::priceAttrType_pskel& cen,
           ::xml_schema::string_pskel& naz,
           ::vfp::basicIdAttrType_pskel& id)
  {
    this->b_parser_ = &b;
    this->cen_parser_ = &cen;
    this->naz_parser_ = &naz;
    this->id_parser_ = &id;
  }

  sol_pskel::
  sol_pskel ()
  : b_parser_ (0),
    cen_parser_ (0),
    naz_parser_ (0),
    id_parser_ (0)
  {
  }

  // por_pskel
  //

  void por_pskel::
  area_parser (::vfp::areaType_pskel& p)
  {
    this->area_parser_ = &p;
  }

  void por_pskel::
  dp_parser (::vfp::kindOfAreaAttrType_pskel& p)
  {
    this->dp_parser_ = &p;
  }

  void por_pskel::
  dpo_parser (::vfp::areaKindLabelAttrType_pskel& p)
  {
    this->dpo_parser_ = &p;
  }

  void por_pskel::
  zv_parser (::vfp::kindOfUseAttrType_pskel& p)
  {
    this->zv_parser_ = &p;
  }

  void por_pskel::
  cen_parser (::vfp::priceAttrType_pskel& p)
  {
    this->cen_parser_ = &p;
  }

  void por_pskel::
  id_parser (::vfp::basicIdAttrType_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void por_pskel::
  parsers (::vfp::areaType_pskel& area,
           ::vfp::kindOfAreaAttrType_pskel& dp,
           ::vfp::areaKindLabelAttrType_pskel& dpo,
           ::vfp::kindOfUseAttrType_pskel& zv,
           ::vfp::priceAttrType_pskel& cen,
           ::vfp::basicIdAttrType_pskel& id)
  {
    this->area_parser_ = &area;
    this->dp_parser_ = &dp;
    this->dpo_parser_ = &dpo;
    this->zv_parser_ = &zv;
    this->cen_parser_ = &cen;
    this->id_parser_ = &id;
  }

  por_pskel::
  por_pskel ()
  : area_parser_ (0),
    dp_parser_ (0),
    dpo_parser_ (0),
    zv_parser_ (0),
    cen_parser_ (0),
    id_parser_ (0)
  {
  }

  // headerType_pskel
  //

  void headerType_pskel::
  dvz_parser (::xml_schema::date_time_pskel& p)
  {
    this->dvz_parser_ = &p;
  }

  void headerType_pskel::
  dkn_parser (::xml_schema::date_time_pskel& p)
  {
    this->dkn_parser_ = &p;
  }

  void headerType_pskel::
  aut_parser (::vfp::notEmptyStringType_pskel& p)
  {
    this->aut_parser_ = &p;
  }

  void headerType_pskel::
  et_parser (::vfp::stageType_pskel& p)
  {
    this->et_parser_ = &p;
  }

  void headerType_pskel::
  kk_parser (::vfp::cadasterCodeType_pskel& p)
  {
    this->kk_parser_ = &p;
  }

  void headerType_pskel::
  typ_parser (::vfp::landConsType_pskel& p)
  {
    this->typ_parser_ = &p;
  }

  void headerType_pskel::
  cpu_parser (::xml_schema::positive_integer_pskel& p)
  {
    this->cpu_parser_ = &p;
  }

  void headerType_pskel::
  ocv_parser (::vfp::ocvType_pskel& p)
  {
    this->ocv_parser_ = &p;
  }

  void headerType_pskel::
  kv_parser (::vfp::koeficientType_pskel& p)
  {
    this->kv_parser_ = &p;
  }

  void headerType_pskel::
  ksz_parser (::vfp::koeficientType_pskel& p)
  {
    this->ksz_parser_ = &p;
  }

  void headerType_pskel::
  ver_parser (::vfp::versionType_pskel& p)
  {
    this->ver_parser_ = &p;
  }

  void headerType_pskel::
  sw_parser (::vfp::notEmptyStringType_pskel& p)
  {
    this->sw_parser_ = &p;
  }

  void headerType_pskel::
  sx_parser (::vfp::coordinateAttrType_pskel& p)
  {
    this->sx_parser_ = &p;
  }

  void headerType_pskel::
  sy_parser (::vfp::coordinateAttrType_pskel& p)
  {
    this->sy_parser_ = &p;
  }

  void headerType_pskel::
  parsers (::xml_schema::date_time_pskel& dvz,
           ::xml_schema::date_time_pskel& dkn,
           ::vfp::notEmptyStringType_pskel& aut,
           ::vfp::stageType_pskel& et,
           ::vfp::cadasterCodeType_pskel& kk,
           ::vfp::landConsType_pskel& typ,
           ::xml_schema::positive_integer_pskel& cpu,
           ::vfp::ocvType_pskel& ocv,
           ::vfp::koeficientType_pskel& kv,
           ::vfp::koeficientType_pskel& ksz,
           ::vfp::versionType_pskel& ver,
           ::vfp::notEmptyStringType_pskel& sw,
           ::vfp::coordinateAttrType_pskel& sx,
           ::vfp::coordinateAttrType_pskel& sy)
  {
    this->dvz_parser_ = &dvz;
    this->dkn_parser_ = &dkn;
    this->aut_parser_ = &aut;
    this->et_parser_ = &et;
    this->kk_parser_ = &kk;
    this->typ_parser_ = &typ;
    this->cpu_parser_ = &cpu;
    this->ocv_parser_ = &ocv;
    this->kv_parser_ = &kv;
    this->ksz_parser_ = &ksz;
    this->ver_parser_ = &ver;
    this->sw_parser_ = &sw;
    this->sx_parser_ = &sx;
    this->sy_parser_ = &sy;
  }

  headerType_pskel::
  headerType_pskel ()
  : dvz_parser_ (0),
    dkn_parser_ (0),
    aut_parser_ (0),
    et_parser_ (0),
    kk_parser_ (0),
    typ_parser_ (0),
    cpu_parser_ (0),
    ocv_parser_ (0),
    kv_parser_ (0),
    ksz_parser_ (0),
    ver_parser_ (0),
    sw_parser_ (0),
    sx_parser_ (0),
    sy_parser_ (0)
  {
  }

  // pbremCollectionType_pskel
  //

  void pbremCollectionType_pskel::
  pl_parser (::vfp::pl2_pskel& p)
  {
    this->pl_parser_ = &p;
  }

  void pbremCollectionType_pskel::
  parsers (::vfp::pl2_pskel& pl)
  {
    this->pl_parser_ = &pl;
  }

  pbremCollectionType_pskel::
  pbremCollectionType_pskel ()
  : pl_parser_ (0)
  {
  }

  // spozCollectionType_pskel
  //

  void spozCollectionType_pskel::
  pl_parser (::vfp::pl3_pskel& p)
  {
    this->pl_parser_ = &p;
  }

  void spozCollectionType_pskel::
  parsers (::vfp::pl3_pskel& pl)
  {
    this->pl_parser_ = &pl;
  }

  spozCollectionType_pskel::
  spozCollectionType_pskel ()
  : pl_parser_ (0)
  {
  }

  // vfpType_pskel
  //

  void vfpType_pskel::
  hlav_parser (::vfp::headerType_pskel& p)
  {
    this->hlav_parser_ = &p;
  }

  void vfpType_pskel::
  ucastnici_parser (::vfp::ucastniciType_pskel& p)
  {
    this->ucastnici_parser_ = &p;
  }

  void vfpType_pskel::
  narok_parser (::vfp::narokType_pskel& p)
  {
    this->narok_parser_ = &p;
  }

  void vfpType_pskel::
  navrh_parser (::vfp::navrhType_pskel& p)
  {
    this->navrh_parser_ = &p;
  }

  void vfpType_pskel::
  pneres_parser (::vfp::pneresType_pskel& p)
  {
    this->pneres_parser_ = &p;
  }

  void vfpType_pskel::
  pmimo_parser (::vfp::outsideParcelType_pskel& p)
  {
    this->pmimo_parser_ = &p;
  }

  void vfpType_pskel::
  bpej_parser (::vfp::bpej_pskel& p)
  {
    this->bpej_parser_ = &p;
  }

  void vfpType_pskel::
  bpejr2_parser (::vfp::bpejr2_pskel& p)
  {
    this->bpejr2_parser_ = &p;
  }

  void vfpType_pskel::
  mdp_parser (::vfp::mdpType_pskel& p)
  {
    this->mdp_parser_ = &p;
  }

  void vfpType_pskel::
  zs_parser (::vfp::zsType_pskel& p)
  {
    this->zs_parser_ = &p;
  }

  void vfpType_pskel::
  opu_parser (::vfp::opuType_pskel& p)
  {
    this->opu_parser_ = &p;
  }

  void vfpType_pskel::
  por_parser (::vfp::por1_pskel& p)
  {
    this->por_parser_ = &p;
  }

  void vfpType_pskel::
  pbre_parser (::vfp::pbremCollectionType_pskel& p)
  {
    this->pbre_parser_ = &p;
  }

  void vfpType_pskel::
  spoz_parser (::vfp::spozCollectionType_pskel& p)
  {
    this->spoz_parser_ = &p;
  }

  void vfpType_pskel::
  pm_parser (::vfp::pmType_pskel& p)
  {
    this->pm_parser_ = &p;
  }

  void vfpType_pskel::
  mp_parser (::vfp::mpType_pskel& p)
  {
    this->mp_parser_ = &p;
  }

  void vfpType_pskel::
  meos_parser (::vfp::meosType_pskel& p)
  {
    this->meos_parser_ = &p;
  }

  void vfpType_pskel::
  meon_parser (::vfp::meonType_pskel& p)
  {
    this->meon_parser_ = &p;
  }

  void vfpType_pskel::
  hvpsz_parser (::vfp::hvpszType_pskel& p)
  {
    this->hvpsz_parser_ = &p;
  }

  void vfpType_pskel::
  zv_parser (::vfp::zv_pskel& p)
  {
    this->zv_parser_ = &p;
  }

  void vfpType_pskel::
  parsers (::vfp::headerType_pskel& hlav,
           ::vfp::ucastniciType_pskel& ucastnici,
           ::vfp::narokType_pskel& narok,
           ::vfp::navrhType_pskel& navrh,
           ::vfp::pneresType_pskel& pneres,
           ::vfp::outsideParcelType_pskel& pmimo,
           ::vfp::bpej_pskel& bpej,
           ::vfp::bpejr2_pskel& bpejr2,
           ::vfp::mdpType_pskel& mdp,
           ::vfp::zsType_pskel& zs,
           ::vfp::opuType_pskel& opu,
           ::vfp::por1_pskel& por,
           ::vfp::pbremCollectionType_pskel& pbre,
           ::vfp::spozCollectionType_pskel& spoz,
           ::vfp::pmType_pskel& pm,
           ::vfp::mpType_pskel& mp,
           ::vfp::meosType_pskel& meos,
           ::vfp::meonType_pskel& meon,
           ::vfp::hvpszType_pskel& hvpsz,
           ::vfp::zv_pskel& zv)
  {
    this->hlav_parser_ = &hlav;
    this->ucastnici_parser_ = &ucastnici;
    this->narok_parser_ = &narok;
    this->navrh_parser_ = &navrh;
    this->pneres_parser_ = &pneres;
    this->pmimo_parser_ = &pmimo;
    this->bpej_parser_ = &bpej;
    this->bpejr2_parser_ = &bpejr2;
    this->mdp_parser_ = &mdp;
    this->zs_parser_ = &zs;
    this->opu_parser_ = &opu;
    this->por_parser_ = &por;
    this->pbre_parser_ = &pbre;
    this->spoz_parser_ = &spoz;
    this->pm_parser_ = &pm;
    this->mp_parser_ = &mp;
    this->meos_parser_ = &meos;
    this->meon_parser_ = &meon;
    this->hvpsz_parser_ = &hvpsz;
    this->zv_parser_ = &zv;
  }

  vfpType_pskel::
  vfpType_pskel ()
  : hlav_parser_ (0),
    ucastnici_parser_ (0),
    narok_parser_ (0),
    navrh_parser_ (0),
    pneres_parser_ (0),
    pmimo_parser_ (0),
    bpej_parser_ (0),
    bpejr2_parser_ (0),
    mdp_parser_ (0),
    zs_parser_ (0),
    opu_parser_ (0),
    por_parser_ (0),
    pbre_parser_ (0),
    spoz_parser_ (0),
    pm_parser_ (0),
    mp_parser_ (0),
    meos_parser_ (0),
    meon_parser_ (0),
    hvpsz_parser_ (0),
    zv_parser_ (0)
  {
  }

  // pa_pskel
  //

  void pa_pskel::
  gpar_parser (::vfp::gparType_pskel& p)
  {
    this->gpar_parser_ = &p;
  }

  void pa_pskel::
  parid_parser (::vfp::parcelIdAttrType_pskel& p)
  {
    this->parid_parser_ = &p;
  }

  void pa_pskel::
  parsers (::vfp::gparType_pskel& gpar,
           ::vfp::parcelIdAttrType_pskel& parid)
  {
    this->gpar_parser_ = &gpar;
    this->parid_parser_ = &parid;
  }

  pa_pskel::
  pa_pskel ()
  : gpar_parser_ (0),
    parid_parser_ (0)
  {
  }

  // pa1_pskel
  //

  void pa1_pskel::
  gpar_parser (::vfp::gparType_pskel& p)
  {
    this->gpar_parser_ = &p;
  }

  void pa1_pskel::
  ncn_parser (::vfp::newNumberCollectionType_pskel& p)
  {
    this->ncn_parser_ = &p;
  }

  void pa1_pskel::
  parid_parser (::vfp::parcelIdAttrType_pskel& p)
  {
    this->parid_parser_ = &p;
  }

  void pa1_pskel::
  vymz_parser (::vfp::areaAttrType_pskel& p)
  {
    this->vymz_parser_ = &p;
  }

  void pa1_pskel::
  dpz_parser (::vfp::kindOfAreaAttrType_pskel& p)
  {
    this->dpz_parser_ = &p;
  }

  void pa1_pskel::
  zvz_parser (::vfp::kindOfUseAttrType_pskel& p)
  {
    this->zvz_parser_ = &p;
  }

  void pa1_pskel::
  parsers (::vfp::gparType_pskel& gpar,
           ::vfp::newNumberCollectionType_pskel& ncn,
           ::vfp::parcelIdAttrType_pskel& parid,
           ::vfp::areaAttrType_pskel& vymz,
           ::vfp::kindOfAreaAttrType_pskel& dpz,
           ::vfp::kindOfUseAttrType_pskel& zvz)
  {
    this->gpar_parser_ = &gpar;
    this->ncn_parser_ = &ncn;
    this->parid_parser_ = &parid;
    this->vymz_parser_ = &vymz;
    this->dpz_parser_ = &dpz;
    this->zvz_parser_ = &zvz;
  }

  pa1_pskel::
  pa1_pskel ()
  : gpar_parser_ (0),
    ncn_parser_ (0),
    parid_parser_ (0),
    vymz_parser_ (0),
    dpz_parser_ (0),
    zvz_parser_ (0)
  {
  }

  // dil_pskel
  //

  void dil_pskel::
  zo_parser (::xml_schema::integer_pskel& p)
  {
    this->zo_parser_ = &p;
  }

  void dil_pskel::
  parsers (::xml_schema::integer_pskel& zo)
  {
    this->zo_parser_ = &zo;
  }

  dil_pskel::
  dil_pskel ()
  : zo_parser_ (0)
  {
  }

  // vla_pskel
  //

  void vla_pskel::
  nvlas_parser (::vfp::nvlaCollectionType_pskel& p)
  {
    this->nvlas_parser_ = &p;
  }

  void vla_pskel::
  op_id_parser (::vfp::opsubIdType_pskel& p)
  {
    this->op_id_parser_ = &p;
  }

  void vla_pskel::
  cit_parser (::vfp::numeratorType_pskel& p)
  {
    this->cit_parser_ = &p;
  }

  void vla_pskel::
  jmen_parser (::vfp::denominatorType_pskel& p)
  {
    this->jmen_parser_ = &p;
  }

  void vla_pskel::
  tpk_parser (::xml_schema::integer_pskel& p)
  {
    this->tpk_parser_ = &p;
  }

  void vla_pskel::
  rus_parser (::vfp::rusAttrType_pskel& p)
  {
    this->rus_parser_ = &p;
  }

  void vla_pskel::
  parsers (::vfp::nvlaCollectionType_pskel& nvlas,
           ::vfp::opsubIdType_pskel& op_id,
           ::vfp::numeratorType_pskel& cit,
           ::vfp::denominatorType_pskel& jmen,
           ::xml_schema::integer_pskel& tpk,
           ::vfp::rusAttrType_pskel& rus)
  {
    this->nvlas_parser_ = &nvlas;
    this->op_id_parser_ = &op_id;
    this->cit_parser_ = &cit;
    this->jmen_parser_ = &jmen;
    this->tpk_parser_ = &tpk;
    this->rus_parser_ = &rus;
  }

  vla_pskel::
  vla_pskel ()
  : nvlas_parser_ (0),
    op_id_parser_ (0),
    cit_parser_ (0),
    jmen_parser_ (0),
    tpk_parser_ (0),
    rus_parser_ (0)
  {
  }

  // lv_pskel
  //

  void lv_pskel::
  par_parser (::vfp::par_pskel& p)
  {
    this->par_parser_ = &p;
  }

  void lv_pskel::
  ucas_parser (::vfp::ucaCollectionType_pskel& p)
  {
    this->ucas_parser_ = &p;
  }

  void lv_pskel::
  kk_parser (::vfp::cadasterCodeType_pskel& p)
  {
    this->kk_parser_ = &p;
  }

  void lv_pskel::
  cis_parser (::vfp::lvNumberAttrType_pskel& p)
  {
    this->cis_parser_ = &p;
  }

  void lv_pskel::
  vymr_parser (::vfp::areaAttrType_pskel& p)
  {
    this->vymr_parser_ = &p;
  }

  void lv_pskel::
  vymnr_parser (::vfp::areaAttrType_pskel& p)
  {
    this->vymnr_parser_ = &p;
  }

  void lv_pskel::
  cen_parser (::vfp::priceAttrType_pskel& p)
  {
    this->cen_parser_ = &p;
  }

  void lv_pskel::
  vzd_parser (::vfp::distanceType_pskel& p)
  {
    this->vzd_parser_ = &p;
  }

  void lv_pskel::
  parsers (::vfp::par_pskel& par,
           ::vfp::ucaCollectionType_pskel& ucas,
           ::vfp::cadasterCodeType_pskel& kk,
           ::vfp::lvNumberAttrType_pskel& cis,
           ::vfp::areaAttrType_pskel& vymr,
           ::vfp::areaAttrType_pskel& vymnr,
           ::vfp::priceAttrType_pskel& cen,
           ::vfp::distanceType_pskel& vzd)
  {
    this->par_parser_ = &par;
    this->ucas_parser_ = &ucas;
    this->kk_parser_ = &kk;
    this->cis_parser_ = &cis;
    this->vymr_parser_ = &vymr;
    this->vymnr_parser_ = &vymnr;
    this->cen_parser_ = &cen;
    this->vzd_parser_ = &vzd;
  }

  lv_pskel::
  lv_pskel ()
  : par_parser_ (0),
    ucas_parser_ (0),
    kk_parser_ (0),
    cis_parser_ (0),
    vymr_parser_ (0),
    vymnr_parser_ (0),
    cen_parser_ (0),
    vzd_parser_ (0)
  {
  }

  // dil1_pskel
  //

  void dil1_pskel::
  typ_parser (::vfp::bpejType_pskel& p)
  {
    this->typ_parser_ = &p;
  }

  void dil1_pskel::
  kod_parser (::vfp::bpejCodeAttrType_pskel& p)
  {
    this->kod_parser_ = &p;
  }

  void dil1_pskel::
  vym_parser (::vfp::areaAttrType_pskel& p)
  {
    this->vym_parser_ = &p;
  }

  void dil1_pskel::
  cen_parser (::vfp::priceAttrType_pskel& p)
  {
    this->cen_parser_ = &p;
  }

  void dil1_pskel::
  poz_parser (::xml_schema::string_pskel& p)
  {
    this->poz_parser_ = &p;
  }

  void dil1_pskel::
  parsers (::vfp::bpejType_pskel& typ,
           ::vfp::bpejCodeAttrType_pskel& kod,
           ::vfp::areaAttrType_pskel& vym,
           ::vfp::priceAttrType_pskel& cen,
           ::xml_schema::string_pskel& poz)
  {
    this->typ_parser_ = &typ;
    this->kod_parser_ = &kod;
    this->vym_parser_ = &vym;
    this->cen_parser_ = &cen;
    this->poz_parser_ = &poz;
  }

  dil1_pskel::
  dil1_pskel ()
  : typ_parser_ (0),
    kod_parser_ (0),
    vym_parser_ (0),
    cen_parser_ (0),
    poz_parser_ (0)
  {
  }

  // dil2_pskel
  //

  void dil2_pskel::
  typ_parser (::vfp::bpejType_pskel& p)
  {
    this->typ_parser_ = &p;
  }

  void dil2_pskel::
  kod_parser (::vfp::bpejCodeAttrType_pskel& p)
  {
    this->kod_parser_ = &p;
  }

  void dil2_pskel::
  vym_parser (::vfp::areaAttrType_pskel& p)
  {
    this->vym_parser_ = &p;
  }

  void dil2_pskel::
  cen_parser (::vfp::priceAttrType_pskel& p)
  {
    this->cen_parser_ = &p;
  }

  void dil2_pskel::
  poz_parser (::xml_schema::string_pskel& p)
  {
    this->poz_parser_ = &p;
  }

  void dil2_pskel::
  dp_parser (::vfp::kindOfAreaAttrType_pskel& p)
  {
    this->dp_parser_ = &p;
  }

  void dil2_pskel::
  zv_parser (::vfp::kindOfUseAttrType_pskel& p)
  {
    this->zv_parser_ = &p;
  }

  void dil2_pskel::
  parsers (::vfp::bpejType_pskel& typ,
           ::vfp::bpejCodeAttrType_pskel& kod,
           ::vfp::areaAttrType_pskel& vym,
           ::vfp::priceAttrType_pskel& cen,
           ::xml_schema::string_pskel& poz,
           ::vfp::kindOfAreaAttrType_pskel& dp,
           ::vfp::kindOfUseAttrType_pskel& zv)
  {
    this->typ_parser_ = &typ;
    this->kod_parser_ = &kod;
    this->vym_parser_ = &vym;
    this->cen_parser_ = &cen;
    this->poz_parser_ = &poz;
    this->dp_parser_ = &dp;
    this->zv_parser_ = &zv;
  }

  dil2_pskel::
  dil2_pskel ()
  : typ_parser_ (0),
    kod_parser_ (0),
    vym_parser_ (0),
    cen_parser_ (0),
    poz_parser_ (0),
    dp_parser_ (0),
    zv_parser_ (0)
  {
  }

  // lv1_pskel
  //

  void lv1_pskel::
  par_parser (::vfp::par1_pskel& p)
  {
    this->par_parser_ = &p;
  }

  void lv1_pskel::
  vlas_parser (::vfp::vlaCollectionType_pskel& p)
  {
    this->vlas_parser_ = &p;
  }

  void lv1_pskel::
  ucas_parser (::vfp::ucaCollectionType_pskel& p)
  {
    this->ucas_parser_ = &p;
  }

  void lv1_pskel::
  cis_parser (::vfp::lvNumberAttrType_pskel& p)
  {
    this->cis_parser_ = &p;
  }

  void lv1_pskel::
  kk_parser (::vfp::cadasterCodeType_pskel& p)
  {
    this->kk_parser_ = &p;
  }

  void lv1_pskel::
  parsers (::vfp::par1_pskel& par,
           ::vfp::vlaCollectionType_pskel& vlas,
           ::vfp::ucaCollectionType_pskel& ucas,
           ::vfp::lvNumberAttrType_pskel& cis,
           ::vfp::cadasterCodeType_pskel& kk)
  {
    this->par_parser_ = &par;
    this->vlas_parser_ = &vlas;
    this->ucas_parser_ = &ucas;
    this->cis_parser_ = &cis;
    this->kk_parser_ = &kk;
  }

  lv1_pskel::
  lv1_pskel ()
  : par_parser_ (0),
    vlas_parser_ (0),
    ucas_parser_ (0),
    cis_parser_ (0),
    kk_parser_ (0)
  {
  }

  // pl_pskel
  //

  void pl_pskel::
  area_parser (::vfp::areaType_pskel& p)
  {
    this->area_parser_ = &p;
  }

  void pl_pskel::
  id_parser (::vfp::basicIdAttrType_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void pl_pskel::
  dp_parser (::vfp::kindOfAreaAttrType_pskel& p)
  {
    this->dp_parser_ = &p;
  }

  void pl_pskel::
  zv_parser (::vfp::kindOfUseAttrType_pskel& p)
  {
    this->zv_parser_ = &p;
  }

  void pl_pskel::
  parsers (::vfp::areaType_pskel& area,
           ::vfp::basicIdAttrType_pskel& id,
           ::vfp::kindOfAreaAttrType_pskel& dp,
           ::vfp::kindOfUseAttrType_pskel& zv)
  {
    this->area_parser_ = &area;
    this->id_parser_ = &id;
    this->dp_parser_ = &dp;
    this->zv_parser_ = &zv;
  }

  pl_pskel::
  pl_pskel ()
  : area_parser_ (0),
    id_parser_ (0),
    dp_parser_ (0),
    zv_parser_ (0)
  {
  }

  // plins_pskel
  //

  void plins_pskel::
  plin_parser (::vfp::plin_pskel& p)
  {
    this->plin_parser_ = &p;
  }

  void plins_pskel::
  parsers (::vfp::plin_pskel& plin)
  {
    this->plin_parser_ = &plin;
  }

  plins_pskel::
  plins_pskel ()
  : plin_parser_ (0)
  {
  }

  // pznas_pskel
  //

  void pznas_pskel::
  pzna_parser (::vfp::pzna_pskel& p)
  {
    this->pzna_parser_ = &p;
  }

  void pznas_pskel::
  parsers (::vfp::pzna_pskel& pzna)
  {
    this->pzna_parser_ = &pzna;
  }

  pznas_pskel::
  pznas_pskel ()
  : pzna_parser_ (0)
  {
  }

  // ptexts_pskel
  //

  void ptexts_pskel::
  ptext_parser (::vfp::ptext_pskel& p)
  {
    this->ptext_parser_ = &p;
  }

  void ptexts_pskel::
  parsers (::vfp::ptext_pskel& ptext)
  {
    this->ptext_parser_ = &ptext;
  }

  ptexts_pskel::
  ptexts_pskel ()
  : ptext_parser_ (0)
  {
  }

  // psour_pskel
  //

  void psour_pskel::
  psou_parser (::vfp::psouType_pskel& p)
  {
    this->psou_parser_ = &p;
  }

  void psour_pskel::
  parsers (::vfp::psouType_pskel& psou)
  {
    this->psou_parser_ = &psou;
  }

  psour_pskel::
  psour_pskel ()
  : psou_parser_ (0)
  {
  }

  // pmlins_pskel
  //

  void pmlins_pskel::
  pmlin_parser (::vfp::plin_pskel& p)
  {
    this->pmlin_parser_ = &p;
  }

  void pmlins_pskel::
  parsers (::vfp::plin_pskel& pmlin)
  {
    this->pmlin_parser_ = &pmlin;
  }

  pmlins_pskel::
  pmlins_pskel ()
  : pmlin_parser_ (0)
  {
  }

  // pmznas_pskel
  //

  void pmznas_pskel::
  pmzna_parser (::vfp::pzna_pskel& p)
  {
    this->pmzna_parser_ = &p;
  }

  void pmznas_pskel::
  parsers (::vfp::pzna_pskel& pmzna)
  {
    this->pmzna_parser_ = &pmzna;
  }

  pmznas_pskel::
  pmznas_pskel ()
  : pmzna_parser_ (0)
  {
  }

  // pmtexts_pskel
  //

  void pmtexts_pskel::
  pmtext_parser (::vfp::ptext_pskel& p)
  {
    this->pmtext_parser_ = &p;
  }

  void pmtexts_pskel::
  parsers (::vfp::ptext_pskel& pmtext)
  {
    this->pmtext_parser_ = &pmtext;
  }

  pmtexts_pskel::
  pmtexts_pskel ()
  : pmtext_parser_ (0)
  {
  }

  // pmareas_pskel
  //

  void pmareas_pskel::
  pmarea_parser (::vfp::parea_pskel& p)
  {
    this->pmarea_parser_ = &p;
  }

  void pmareas_pskel::
  parsers (::vfp::parea_pskel& pmarea)
  {
    this->pmarea_parser_ = &pmarea;
  }

  pmareas_pskel::
  pmareas_pskel ()
  : pmarea_parser_ (0)
  {
  }

  // mplins_pskel
  //

  void mplins_pskel::
  mplin_parser (::vfp::plin_pskel& p)
  {
    this->mplin_parser_ = &p;
  }

  void mplins_pskel::
  parsers (::vfp::plin_pskel& mplin)
  {
    this->mplin_parser_ = &mplin;
  }

  mplins_pskel::
  mplins_pskel ()
  : mplin_parser_ (0)
  {
  }

  // mpznas_pskel
  //

  void mpznas_pskel::
  mpzna_parser (::vfp::pzna_pskel& p)
  {
    this->mpzna_parser_ = &p;
  }

  void mpznas_pskel::
  parsers (::vfp::pzna_pskel& mpzna)
  {
    this->mpzna_parser_ = &mpzna;
  }

  mpznas_pskel::
  mpznas_pskel ()
  : mpzna_parser_ (0)
  {
  }

  // mptexts_pskel
  //

  void mptexts_pskel::
  mptext_parser (::vfp::ptext_pskel& p)
  {
    this->mptext_parser_ = &p;
  }

  void mptexts_pskel::
  parsers (::vfp::ptext_pskel& mptext)
  {
    this->mptext_parser_ = &mptext;
  }

  mptexts_pskel::
  mptexts_pskel ()
  : mptext_parser_ (0)
  {
  }

  // mpareas_pskel
  //

  void mpareas_pskel::
  mparea_parser (::vfp::parea_pskel& p)
  {
    this->mparea_parser_ = &p;
  }

  void mpareas_pskel::
  parsers (::vfp::parea_pskel& mparea)
  {
    this->mparea_parser_ = &mparea;
  }

  mpareas_pskel::
  mpareas_pskel ()
  : mparea_parser_ (0)
  {
  }

  // meoslins_pskel
  //

  void meoslins_pskel::
  meoslin_parser (::vfp::plin_pskel& p)
  {
    this->meoslin_parser_ = &p;
  }

  void meoslins_pskel::
  parsers (::vfp::plin_pskel& meoslin)
  {
    this->meoslin_parser_ = &meoslin;
  }

  meoslins_pskel::
  meoslins_pskel ()
  : meoslin_parser_ (0)
  {
  }

  // meosznas_pskel
  //

  void meosznas_pskel::
  meoszna_parser (::vfp::pzna_pskel& p)
  {
    this->meoszna_parser_ = &p;
  }

  void meosznas_pskel::
  parsers (::vfp::pzna_pskel& meoszna)
  {
    this->meoszna_parser_ = &meoszna;
  }

  meosznas_pskel::
  meosznas_pskel ()
  : meoszna_parser_ (0)
  {
  }

  // meostexts_pskel
  //

  void meostexts_pskel::
  meostext_parser (::vfp::ptext_pskel& p)
  {
    this->meostext_parser_ = &p;
  }

  void meostexts_pskel::
  parsers (::vfp::ptext_pskel& meostext)
  {
    this->meostext_parser_ = &meostext;
  }

  meostexts_pskel::
  meostexts_pskel ()
  : meostext_parser_ (0)
  {
  }

  // meosareas_pskel
  //

  void meosareas_pskel::
  meosarea_parser (::vfp::parea_pskel& p)
  {
    this->meosarea_parser_ = &p;
  }

  void meosareas_pskel::
  parsers (::vfp::parea_pskel& meosarea)
  {
    this->meosarea_parser_ = &meosarea;
  }

  meosareas_pskel::
  meosareas_pskel ()
  : meosarea_parser_ (0)
  {
  }

  // meonlins_pskel
  //

  void meonlins_pskel::
  meonlin_parser (::vfp::plin_pskel& p)
  {
    this->meonlin_parser_ = &p;
  }

  void meonlins_pskel::
  parsers (::vfp::plin_pskel& meonlin)
  {
    this->meonlin_parser_ = &meonlin;
  }

  meonlins_pskel::
  meonlins_pskel ()
  : meonlin_parser_ (0)
  {
  }

  // meonznas_pskel
  //

  void meonznas_pskel::
  meonzna_parser (::vfp::pzna_pskel& p)
  {
    this->meonzna_parser_ = &p;
  }

  void meonznas_pskel::
  parsers (::vfp::pzna_pskel& meonzna)
  {
    this->meonzna_parser_ = &meonzna;
  }

  meonznas_pskel::
  meonznas_pskel ()
  : meonzna_parser_ (0)
  {
  }

  // meontexts_pskel
  //

  void meontexts_pskel::
  meontext_parser (::vfp::ptext_pskel& p)
  {
    this->meontext_parser_ = &p;
  }

  void meontexts_pskel::
  parsers (::vfp::ptext_pskel& meontext)
  {
    this->meontext_parser_ = &meontext;
  }

  meontexts_pskel::
  meontexts_pskel ()
  : meontext_parser_ (0)
  {
  }

  // meonareas_pskel
  //

  void meonareas_pskel::
  meonarea_parser (::vfp::parea_pskel& p)
  {
    this->meonarea_parser_ = &p;
  }

  void meonareas_pskel::
  parsers (::vfp::parea_pskel& meonarea)
  {
    this->meonarea_parser_ = &meonarea;
  }

  meonareas_pskel::
  meonareas_pskel ()
  : meonarea_parser_ (0)
  {
  }

  // hvpszlins_pskel
  //

  void hvpszlins_pskel::
  hvpszlin_parser (::vfp::plin_pskel& p)
  {
    this->hvpszlin_parser_ = &p;
  }

  void hvpszlins_pskel::
  parsers (::vfp::plin_pskel& hvpszlin)
  {
    this->hvpszlin_parser_ = &hvpszlin;
  }

  hvpszlins_pskel::
  hvpszlins_pskel ()
  : hvpszlin_parser_ (0)
  {
  }

  // hvpszznas_pskel
  //

  void hvpszznas_pskel::
  hvpszzna_parser (::vfp::pzna_pskel& p)
  {
    this->hvpszzna_parser_ = &p;
  }

  void hvpszznas_pskel::
  parsers (::vfp::pzna_pskel& hvpszzna)
  {
    this->hvpszzna_parser_ = &hvpszzna;
  }

  hvpszznas_pskel::
  hvpszznas_pskel ()
  : hvpszzna_parser_ (0)
  {
  }

  // hvpsztexts_pskel
  //

  void hvpsztexts_pskel::
  hvpsztext_parser (::vfp::ptext_pskel& p)
  {
    this->hvpsztext_parser_ = &p;
  }

  void hvpsztexts_pskel::
  parsers (::vfp::ptext_pskel& hvpsztext)
  {
    this->hvpsztext_parser_ = &hvpsztext;
  }

  hvpsztexts_pskel::
  hvpsztexts_pskel ()
  : hvpsztext_parser_ (0)
  {
  }

  // hvpszareas_pskel
  //

  void hvpszareas_pskel::
  hvpszarea_parser (::vfp::parea_pskel& p)
  {
    this->hvpszarea_parser_ = &p;
  }

  void hvpszareas_pskel::
  parsers (::vfp::parea_pskel& hvpszarea)
  {
    this->hvpszarea_parser_ = &hvpszarea;
  }

  hvpszareas_pskel::
  hvpszareas_pskel ()
  : hvpszarea_parser_ (0)
  {
  }

  // zvbod_pskel
  //

  void zvbod_pskel::
  c_parser (::vfp::coordinateType_pskel& p)
  {
    this->c_parser_ = &p;
  }

  void zvbod_pskel::
  cb_parser (::xml_schema::integer_pskel& p)
  {
    this->cb_parser_ = &p;
  }

  void zvbod_pskel::
  parsers (::vfp::coordinateType_pskel& c,
           ::xml_schema::integer_pskel& cb)
  {
    this->c_parser_ = &c;
    this->cb_parser_ = &cb;
  }

  zvbod_pskel::
  zvbod_pskel ()
  : c_parser_ (0),
    cb_parser_ (0)
  {
  }

  // zvlin_pskel
  //

  void zvlin_pskel::
  lin_parser (::vfp::linearType_pskel& p)
  {
    this->lin_parser_ = &p;
  }

  void zvlin_pskel::
  parsers (::vfp::linearType_pskel& lin)
  {
    this->lin_parser_ = &lin;
  }

  zvlin_pskel::
  zvlin_pskel ()
  : lin_parser_ (0)
  {
  }

  // zvarea_pskel
  //

  void zvarea_pskel::
  reg_parser (::vfp::regionType_pskel& p)
  {
    this->reg_parser_ = &p;
  }

  void zvarea_pskel::
  parsers (::vfp::regionType_pskel& reg)
  {
    this->reg_parser_ = &reg;
  }

  zvarea_pskel::
  zvarea_pskel ()
  : reg_parser_ (0)
  {
  }

  // pl1_pskel
  //

  void pl1_pskel::
  reg_parser (::vfp::regionType_pskel& p)
  {
    this->reg_parser_ = &p;
  }

  void pl1_pskel::
  sour_parser (::vfp::sour_pskel& p)
  {
    this->sour_parser_ = &p;
  }

  void pl1_pskel::
  id_parser (::vfp::basicIdAttrType_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void pl1_pskel::
  res_parser (::vfp::resAttrType_pskel& p)
  {
    this->res_parser_ = &p;
  }

  void pl1_pskel::
  poz_parser (::vfp::noteAttrType_pskel& p)
  {
    this->poz_parser_ = &p;
  }

  void pl1_pskel::
  parsers (::vfp::regionType_pskel& reg,
           ::vfp::sour_pskel& sour,
           ::vfp::basicIdAttrType_pskel& id,
           ::vfp::resAttrType_pskel& res,
           ::vfp::noteAttrType_pskel& poz)
  {
    this->reg_parser_ = &reg;
    this->sour_parser_ = &sour;
    this->id_parser_ = &id;
    this->res_parser_ = &res;
    this->poz_parser_ = &poz;
  }

  pl1_pskel::
  pl1_pskel ()
  : reg_parser_ (0),
    sour_parser_ (0),
    id_parser_ (0),
    res_parser_ (0),
    poz_parser_ (0)
  {
  }

  // pl2_pskel
  //

  void pl2_pskel::
  area_parser (::vfp::areaType_pskel& p)
  {
    this->area_parser_ = &p;
  }

  void pl2_pskel::
  id_parser (::vfp::basicIdAttrType_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void pl2_pskel::
  typ_parser (::vfp::typPravAttrType_pskel& p)
  {
    this->typ_parser_ = &p;
  }

  void pl2_pskel::
  popis_parser (::vfp::notEmptyStringType_pskel& p)
  {
    this->popis_parser_ = &p;
  }

  void pl2_pskel::
  parsers (::vfp::areaType_pskel& area,
           ::vfp::basicIdAttrType_pskel& id,
           ::vfp::typPravAttrType_pskel& typ,
           ::vfp::notEmptyStringType_pskel& popis)
  {
    this->area_parser_ = &area;
    this->id_parser_ = &id;
    this->typ_parser_ = &typ;
    this->popis_parser_ = &popis;
  }

  pl2_pskel::
  pl2_pskel ()
  : area_parser_ (0),
    id_parser_ (0),
    typ_parser_ (0),
    popis_parser_ (0)
  {
  }

  // pl3_pskel
  //

  void pl3_pskel::
  area_parser (::vfp::areaType_pskel& p)
  {
    this->area_parser_ = &p;
  }

  void pl3_pskel::
  id_parser (::vfp::basicIdAttrType_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void pl3_pskel::
  op_parser (::xml_schema::integer_pskel& p)
  {
    this->op_parser_ = &p;
  }

  void pl3_pskel::
  psz_parser (::vfp::notEmptyStringType_pskel& p)
  {
    this->psz_parser_ = &p;
  }

  void pl3_pskel::
  parsers (::vfp::areaType_pskel& area,
           ::vfp::basicIdAttrType_pskel& id,
           ::xml_schema::integer_pskel& op,
           ::vfp::notEmptyStringType_pskel& psz)
  {
    this->area_parser_ = &area;
    this->id_parser_ = &id;
    this->op_parser_ = &op;
    this->psz_parser_ = &psz;
  }

  pl3_pskel::
  pl3_pskel ()
  : area_parser_ (0),
    id_parser_ (0),
    op_parser_ (0),
    psz_parser_ (0)
  {
  }

  // bpej_pskel
  //

  void bpej_pskel::
  pl_parser (::vfp::pl4_pskel& p)
  {
    this->pl_parser_ = &p;
  }

  void bpej_pskel::
  parsers (::vfp::pl4_pskel& pl)
  {
    this->pl_parser_ = &pl;
  }

  bpej_pskel::
  bpej_pskel ()
  : pl_parser_ (0)
  {
  }

  // bpejr2_pskel
  //

  void bpejr2_pskel::
  pl_parser (::vfp::pl5_pskel& p)
  {
    this->pl_parser_ = &p;
  }

  void bpejr2_pskel::
  parsers (::vfp::pl5_pskel& pl)
  {
    this->pl_parser_ = &pl;
  }

  bpejr2_pskel::
  bpejr2_pskel ()
  : pl_parser_ (0)
  {
  }

  // por1_pskel
  //

  void por1_pskel::
  porost_parser (::vfp::porostType_pskel& p)
  {
    this->porost_parser_ = &p;
  }

  void por1_pskel::
  parsers (::vfp::porostType_pskel& porost)
  {
    this->porost_parser_ = &porost;
  }

  por1_pskel::
  por1_pskel ()
  : porost_parser_ (0)
  {
  }

  // zv_pskel
  //

  void zv_pskel::
  zvbods_parser (::vfp::zvbodsType_pskel& p)
  {
    this->zvbods_parser_ = &p;
  }

  void zv_pskel::
  zvlins_parser (::vfp::zvlinsType_pskel& p)
  {
    this->zvlins_parser_ = &p;
  }

  void zv_pskel::
  zvareas_parser (::vfp::zvareasType_pskel& p)
  {
    this->zvareas_parser_ = &p;
  }

  void zv_pskel::
  parsers (::vfp::zvbodsType_pskel& zvbods,
           ::vfp::zvlinsType_pskel& zvlins,
           ::vfp::zvareasType_pskel& zvareas)
  {
    this->zvbods_parser_ = &zvbods;
    this->zvlins_parser_ = &zvlins;
    this->zvareas_parser_ = &zvareas;
  }

  zv_pskel::
  zv_pskel ()
  : zvbods_parser_ (0),
    zvlins_parser_ (0),
    zvareas_parser_ (0)
  {
  }

  // par_pskel
  //

  void par_pskel::
  pa_parser (::vfp::pa2_pskel& p)
  {
    this->pa_parser_ = &p;
  }

  void par_pskel::
  parsers (::vfp::pa2_pskel& pa)
  {
    this->pa_parser_ = &pa;
  }

  par_pskel::
  par_pskel ()
  : pa_parser_ (0)
  {
  }

  // par1_pskel
  //

  void par1_pskel::
  pa_parser (::vfp::pa3_pskel& p)
  {
    this->pa_parser_ = &p;
  }

  void par1_pskel::
  parsers (::vfp::pa3_pskel& pa)
  {
    this->pa_parser_ = &pa;
  }

  par1_pskel::
  par1_pskel ()
  : pa_parser_ (0)
  {
  }

  // sour_pskel
  //

  void sour_pskel::
  sou_parser (::vfp::souType_pskel& p)
  {
    this->sou_parser_ = &p;
  }

  void sour_pskel::
  parsers (::vfp::souType_pskel& sou)
  {
    this->sou_parser_ = &sou;
  }

  sour_pskel::
  sour_pskel ()
  : sou_parser_ (0)
  {
  }

  // pl4_pskel
  //

  void pl4_pskel::
  area_parser (::vfp::areaType_pskel& p)
  {
    this->area_parser_ = &p;
  }

  void pl4_pskel::
  id_parser (::vfp::basicIdAttrType_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void pl4_pskel::
  kod_parser (::vfp::bpejCodeAttrType_pskel& p)
  {
    this->kod_parser_ = &p;
  }

  void pl4_pskel::
  cena_parser (::vfp::priceAttrType_pskel& p)
  {
    this->cena_parser_ = &p;
  }

  void pl4_pskel::
  parsers (::vfp::areaType_pskel& area,
           ::vfp::basicIdAttrType_pskel& id,
           ::vfp::bpejCodeAttrType_pskel& kod,
           ::vfp::priceAttrType_pskel& cena)
  {
    this->area_parser_ = &area;
    this->id_parser_ = &id;
    this->kod_parser_ = &kod;
    this->cena_parser_ = &cena;
  }

  pl4_pskel::
  pl4_pskel ()
  : area_parser_ (0),
    id_parser_ (0),
    kod_parser_ (0),
    cena_parser_ (0)
  {
  }

  // pl5_pskel
  //

  void pl5_pskel::
  area_parser (::vfp::areaType_pskel& p)
  {
    this->area_parser_ = &p;
  }

  void pl5_pskel::
  id_parser (::vfp::basicIdAttrType_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void pl5_pskel::
  kod_parser (::vfp::bpejCodeAttrType_pskel& p)
  {
    this->kod_parser_ = &p;
  }

  void pl5_pskel::
  parsers (::vfp::areaType_pskel& area,
           ::vfp::basicIdAttrType_pskel& id,
           ::vfp::bpejCodeAttrType_pskel& kod)
  {
    this->area_parser_ = &area;
    this->id_parser_ = &id;
    this->kod_parser_ = &kod;
  }

  pl5_pskel::
  pl5_pskel ()
  : area_parser_ (0),
    id_parser_ (0),
    kod_parser_ (0)
  {
  }

  // pa2_pskel
  //

  void pa2_pskel::
  area_parser (::vfp::areaType_pskel& p)
  {
    this->area_parser_ = &p;
  }

  void pa2_pskel::
  bpej_parser (::vfp::bpejCollectionType_pskel& p)
  {
    this->bpej_parser_ = &p;
  }

  void pa2_pskel::
  brem_parser (::vfp::bremCollectionType_pskel& p)
  {
    this->brem_parser_ = &p;
  }

  void pa2_pskel::
  ochr_parser (::vfp::ochrType_pskel& p)
  {
    this->ochr_parser_ = &p;
  }

  void pa2_pskel::
  por_parser (::vfp::porCollectionType_pskel& p)
  {
    this->por_parser_ = &p;
  }

  void pa2_pskel::
  id_parser (::vfp::parcelIdAttrType_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void pa2_pskel::
  kcpp_parser (::vfp::parcelNumberAttrType_pskel& p)
  {
    this->kcpp_parser_ = &p;
  }

  void pa2_pskel::
  pcpp_parser (::vfp::poddeleniNumberAttrType_pskel& p)
  {
    this->pcpp_parser_ = &p;
  }

  void pa2_pskel::
  dcpp_parser (::vfp::druhCislovaniNumberAttrType_pskel& p)
  {
    this->dcpp_parser_ = &p;
  }

  void pa2_pskel::
  kcp_parser (::vfp::parcelNumberAttrType_pskel& p)
  {
    this->kcp_parser_ = &p;
  }

  void pa2_pskel::
  pcp_parser (::vfp::poddeleniNumberAttrType_pskel& p)
  {
    this->pcp_parser_ = &p;
  }

  void pa2_pskel::
  dcp_parser (::vfp::druhCislovaniNumberAttrType_pskel& p)
  {
    this->dcp_parser_ = &p;
  }

  void pa2_pskel::
  kk_parser (::vfp::cadasterCodeType_pskel& p)
  {
    this->kk_parser_ = &p;
  }

  void pa2_pskel::
  vym_parser (::vfp::areaAttrType_pskel& p)
  {
    this->vym_parser_ = &p;
  }

  void pa2_pskel::
  vzd_parser (::vfp::distanceType_pskel& p)
  {
    this->vzd_parser_ = &p;
  }

  void pa2_pskel::
  dp_parser (::vfp::kindOfAreaAttrType_pskel& p)
  {
    this->dp_parser_ = &p;
  }

  void pa2_pskel::
  zv_parser (::vfp::kindOfUseAttrType_pskel& p)
  {
    this->zv_parser_ = &p;
  }

  void pa2_pskel::
  res_parser (::vfp::resAttrType_pskel& p)
  {
    this->res_parser_ = &p;
  }

  void pa2_pskel::
  poz_parser (::vfp::noteAttrType_pskel& p)
  {
    this->poz_parser_ = &p;
  }

  void pa2_pskel::
  bu_id_parser (::vfp::basicStringIdAttrType_pskel& p)
  {
    this->bu_id_parser_ = &p;
  }

  void pa2_pskel::
  cir_parser (::vfp::cirAttrType_pskel& p)
  {
    this->cir_parser_ = &p;
  }

  void pa2_pskel::
  ps_id_parser (::vfp::basicStringIdAttrType_pskel& p)
  {
    this->ps_id_parser_ = &p;
  }

  void pa2_pskel::
  souc_parser (::vfp::soucAttrType_pskel& p)
  {
    this->souc_parser_ = &p;
  }

  void pa2_pskel::
  parsers (::vfp::areaType_pskel& area,
           ::vfp::bpejCollectionType_pskel& bpej,
           ::vfp::bremCollectionType_pskel& brem,
           ::vfp::ochrType_pskel& ochr,
           ::vfp::porCollectionType_pskel& por,
           ::vfp::parcelIdAttrType_pskel& id,
           ::vfp::parcelNumberAttrType_pskel& kcpp,
           ::vfp::poddeleniNumberAttrType_pskel& pcpp,
           ::vfp::druhCislovaniNumberAttrType_pskel& dcpp,
           ::vfp::parcelNumberAttrType_pskel& kcp,
           ::vfp::poddeleniNumberAttrType_pskel& pcp,
           ::vfp::druhCislovaniNumberAttrType_pskel& dcp,
           ::vfp::cadasterCodeType_pskel& kk,
           ::vfp::areaAttrType_pskel& vym,
           ::vfp::distanceType_pskel& vzd,
           ::vfp::kindOfAreaAttrType_pskel& dp,
           ::vfp::kindOfUseAttrType_pskel& zv,
           ::vfp::resAttrType_pskel& res,
           ::vfp::noteAttrType_pskel& poz,
           ::vfp::basicStringIdAttrType_pskel& bu_id,
           ::vfp::cirAttrType_pskel& cir,
           ::vfp::basicStringIdAttrType_pskel& ps_id,
           ::vfp::soucAttrType_pskel& souc)
  {
    this->area_parser_ = &area;
    this->bpej_parser_ = &bpej;
    this->brem_parser_ = &brem;
    this->ochr_parser_ = &ochr;
    this->por_parser_ = &por;
    this->id_parser_ = &id;
    this->kcpp_parser_ = &kcpp;
    this->pcpp_parser_ = &pcpp;
    this->dcpp_parser_ = &dcpp;
    this->kcp_parser_ = &kcp;
    this->pcp_parser_ = &pcp;
    this->dcp_parser_ = &dcp;
    this->kk_parser_ = &kk;
    this->vym_parser_ = &vym;
    this->vzd_parser_ = &vzd;
    this->dp_parser_ = &dp;
    this->zv_parser_ = &zv;
    this->res_parser_ = &res;
    this->poz_parser_ = &poz;
    this->bu_id_parser_ = &bu_id;
    this->cir_parser_ = &cir;
    this->ps_id_parser_ = &ps_id;
    this->souc_parser_ = &souc;
  }

  pa2_pskel::
  pa2_pskel ()
  : area_parser_ (0),
    bpej_parser_ (0),
    brem_parser_ (0),
    ochr_parser_ (0),
    por_parser_ (0),
    id_parser_ (0),
    kcpp_parser_ (0),
    pcpp_parser_ (0),
    dcpp_parser_ (0),
    kcp_parser_ (0),
    pcp_parser_ (0),
    dcp_parser_ (0),
    kk_parser_ (0),
    vym_parser_ (0),
    vzd_parser_ (0),
    dp_parser_ (0),
    zv_parser_ (0),
    res_parser_ (0),
    poz_parser_ (0),
    bu_id_parser_ (0),
    cir_parser_ (0),
    ps_id_parser_ (0),
    souc_parser_ (0)
  {
  }

  // pa3_pskel
  //

  void pa3_pskel::
  gpar_parser (::vfp::gparType_pskel& p)
  {
    this->gpar_parser_ = &p;
  }

  void pa3_pskel::
  bpej_parser (::vfp::claimBpejCollectionType_pskel& p)
  {
    this->bpej_parser_ = &p;
  }

  void pa3_pskel::
  por_parser (::vfp::porCollectionType_pskel& p)
  {
    this->por_parser_ = &p;
  }

  void pa3_pskel::
  parid_parser (::vfp::parcelIdAttrType_pskel& p)
  {
    this->parid_parser_ = &p;
  }

  void pa3_pskel::
  vymo_parser (::vfp::areaAttrType_pskel& p)
  {
    this->vymo_parser_ = &p;
  }

  void pa3_pskel::
  vzd_parser (::vfp::distanceType_pskel& p)
  {
    this->vzd_parser_ = &p;
  }

  void pa3_pskel::
  vymg_parser (::vfp::areaAttrType_pskel& p)
  {
    this->vymg_parser_ = &p;
  }

  void pa3_pskel::
  poz_parser (::vfp::noteAttrType_pskel& p)
  {
    this->poz_parser_ = &p;
  }

  void pa3_pskel::
  cir_parser (::vfp::cirAttrType_pskel& p)
  {
    this->cir_parser_ = &p;
  }

  void pa3_pskel::
  parsers (::vfp::gparType_pskel& gpar,
           ::vfp::claimBpejCollectionType_pskel& bpej,
           ::vfp::porCollectionType_pskel& por,
           ::vfp::parcelIdAttrType_pskel& parid,
           ::vfp::areaAttrType_pskel& vymo,
           ::vfp::distanceType_pskel& vzd,
           ::vfp::areaAttrType_pskel& vymg,
           ::vfp::noteAttrType_pskel& poz,
           ::vfp::cirAttrType_pskel& cir)
  {
    this->gpar_parser_ = &gpar;
    this->bpej_parser_ = &bpej;
    this->por_parser_ = &por;
    this->parid_parser_ = &parid;
    this->vymo_parser_ = &vymo;
    this->vzd_parser_ = &vzd;
    this->vymg_parser_ = &vymg;
    this->poz_parser_ = &poz;
    this->cir_parser_ = &cir;
  }

  pa3_pskel::
  pa3_pskel ()
  : gpar_parser_ (0),
    bpej_parser_ (0),
    por_parser_ (0),
    parid_parser_ (0),
    vymo_parser_ (0),
    vzd_parser_ (0),
    vymg_parser_ (0),
    poz_parser_ (0),
    cir_parser_ (0)
  {
  }
}

namespace vfp
{
  // coordinateAttrType_pskel
  //

  void coordinateAttrType_pskel::
  post_coordinateAttrType ()
  {
  }

  // coordinateType_pskel
  //

  void coordinateType_pskel::
  x ()
  {
  }

  void coordinateType_pskel::
  y ()
  {
  }

  void coordinateType_pskel::
  z ()
  {
  }

  void coordinateType_pskel::
  post_coordinateType ()
  {
  }

  bool coordinateType_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
      return true;

    if (n == "x" && ns.empty ())
    {
      if (this->x_parser_)
      {
        this->x_parser_->pre ();
        this->x_parser_->_pre_impl ();
        this->x_parser_->_characters (v);
        this->x_parser_->_post_impl ();
        this->x_parser_->post_coordinateAttrType ();
        this->x ();
      }

      return true;
    }

    if (n == "y" && ns.empty ())
    {
      if (this->y_parser_)
      {
        this->y_parser_->pre ();
        this->y_parser_->_pre_impl ();
        this->y_parser_->_characters (v);
        this->y_parser_->_post_impl ();
        this->y_parser_->post_coordinateAttrType ();
        this->y ();
      }

      return true;
    }

    if (n == "z" && ns.empty ())
    {
      if (this->z_parser_)
      {
        this->z_parser_->pre ();
        this->z_parser_->_pre_impl ();
        this->z_parser_->_characters (v);
        this->z_parser_->_post_impl ();
        this->z_parser_->post_coordinateAttrType ();
        this->z ();
      }

      return true;
    }

    return false;
  }

  // polygonType_pskel
  //

  void polygonType_pskel::
  post_polygonType ()
  {
  }

  // linpol_pskel
  //

  void linpol_pskel::
  segment ()
  {
  }

  void linpol_pskel::
  post_linpol ()
  {
    post_polygonType ();
  }

  bool linpol_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::vfp::polygonType_pskel::_start_element_impl (ns, n, t))
      return true;

    if (n == "segment" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->segment_parser_;

      if (this->segment_parser_)
        this->segment_parser_->pre ();

      return true;
    }

    return false;
  }

  bool linpol_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::vfp::polygonType_pskel::_end_element_impl (ns, n))
      return true;

    if (n == "segment" && ns.empty ())
    {
      if (this->segment_parser_)
      {
        this->segment_parser_->post_segmentType ();
        this->segment ();
      }

      return true;
    }

    return false;
  }

  // linearType_pskel
  //

  void linearType_pskel::
  segment ()
  {
  }

  void linearType_pskel::
  post_linearType ()
  {
  }

  bool linearType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "segment" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->segment_parser_;

      if (this->segment_parser_)
        this->segment_parser_->pre ();

      return true;
    }

    return false;
  }

  bool linearType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "segment" && ns.empty ())
    {
      if (this->segment_parser_)
      {
        this->segment_parser_->post_segmentType ();
        this->segment ();
      }

      return true;
    }

    return false;
  }

  // circle_pskel
  //

  void circle_pskel::
  c ()
  {
  }

  void circle_pskel::
  r ()
  {
  }

  void circle_pskel::
  post_circle ()
  {
    post_polygonType ();
  }

  bool circle_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::vfp::polygonType_pskel::_start_element_impl (ns, n, t))
      return true;

    if (n == "c" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->c_parser_;

      if (this->c_parser_)
        this->c_parser_->pre ();

      return true;
    }

    return false;
  }

  bool circle_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::vfp::polygonType_pskel::_end_element_impl (ns, n))
      return true;

    if (n == "c" && ns.empty ())
    {
      if (this->c_parser_)
      {
        this->c_parser_->post_coordinateType ();
        this->c ();
      }

      return true;
    }

    return false;
  }

  bool circle_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::vfp::polygonType_pskel::_attribute_impl (ns, n, v))
      return true;

    if (n == "r" && ns.empty ())
    {
      if (this->r_parser_)
      {
        this->r_parser_->pre ();
        this->r_parser_->_pre_impl ();
        this->r_parser_->_characters (v);
        this->r_parser_->_post_impl ();
        this->r_parser_->post_radiusAttrType ();
        this->r ();
      }

      return true;
    }

    return false;
  }

  // solidType_pskel
  //

  void solidType_pskel::
  polygon ()
  {
  }

  void solidType_pskel::
  post_solidType ()
  {
  }

  bool solidType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "polygon" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->polygon_parser_;

      if (this->polygon_parser_)
        this->polygon_parser_->pre ();

      return true;
    }

    return false;
  }

  bool solidType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "polygon" && ns.empty ())
    {
      if (this->polygon_parser_)
      {
        this->polygon_parser_->post_polygonType ();
        this->polygon ();
      }

      return true;
    }

    return false;
  }

  // holeCollectionType_pskel
  //

  void holeCollectionType_pskel::
  polygon ()
  {
  }

  void holeCollectionType_pskel::
  post_holeCollectionType ()
  {
  }

  bool holeCollectionType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "polygon" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->polygon_parser_;

      if (this->polygon_parser_)
        this->polygon_parser_->pre ();

      return true;
    }

    return false;
  }

  bool holeCollectionType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "polygon" && ns.empty ())
    {
      if (this->polygon_parser_)
      {
        this->polygon_parser_->post_polygonType ();
        this->polygon ();
      }

      return true;
    }

    return false;
  }

  // regionType_pskel
  //

  void regionType_pskel::
  solid ()
  {
  }

  void regionType_pskel::
  holes ()
  {
  }

  void regionType_pskel::
  post_regionType ()
  {
  }

  bool regionType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "solid" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->solid_parser_;

      if (this->solid_parser_)
        this->solid_parser_->pre ();

      return true;
    }

    if (n == "holes" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->holes_parser_;

      if (this->holes_parser_)
        this->holes_parser_->pre ();

      return true;
    }

    return false;
  }

  bool regionType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "solid" && ns.empty ())
    {
      if (this->solid_parser_)
      {
        this->solid_parser_->post_solidType ();
        this->solid ();
      }

      return true;
    }

    if (n == "holes" && ns.empty ())
    {
      if (this->holes_parser_)
      {
        this->holes_parser_->post_holeCollectionType ();
        this->holes ();
      }

      return true;
    }

    return false;
  }

  // segmentType_pskel
  //

  void segmentType_pskel::
  post_segmentType ()
  {
  }

  // se_pskel
  //

  void se_pskel::
  c ()
  {
  }

  void se_pskel::
  post_se ()
  {
    post_segmentType ();
  }

  bool se_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::vfp::segmentType_pskel::_start_element_impl (ns, n, t))
      return true;

    if (n == "c" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->c_parser_;

      if (this->c_parser_)
        this->c_parser_->pre ();

      return true;
    }

    return false;
  }

  bool se_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::vfp::segmentType_pskel::_end_element_impl (ns, n))
      return true;

    if (n == "c" && ns.empty ())
    {
      if (this->c_parser_)
      {
        this->c_parser_->post_coordinateType ();
        this->c ();
      }

      return true;
    }

    return false;
  }

  // ar_pskel
  //

  void ar_pskel::
  c ()
  {
  }

  void ar_pskel::
  post_ar ()
  {
    post_segmentType ();
  }

  bool ar_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::vfp::segmentType_pskel::_start_element_impl (ns, n, t))
      return true;

    if (n == "c" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->c_parser_;

      if (this->c_parser_)
        this->c_parser_->pre ();

      return true;
    }

    return false;
  }

  bool ar_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::vfp::segmentType_pskel::_end_element_impl (ns, n))
      return true;

    if (n == "c" && ns.empty ())
    {
      if (this->c_parser_)
      {
        this->c_parser_->post_coordinateType ();
        this->c ();
      }

      return true;
    }

    return false;
  }

  // radiusAttrType_pskel
  //

  void radiusAttrType_pskel::
  post_radiusAttrType ()
  {
  }

  // rotationAttrType_pskel
  //

  void rotationAttrType_pskel::
  post_rotationAttrType ()
  {
  }

  // justificationAttrType_pskel
  //

  void justificationAttrType_pskel::
  post_justificationAttrType ()
  {
  }

  // heightAttrType_pskel
  //

  void heightAttrType_pskel::
  post_heightAttrType ()
  {
  }

  // widthAttrType_pskel
  //

  void widthAttrType_pskel::
  post_widthAttrType ()
  {
  }

  // valueAttrType_pskel
  //

  void valueAttrType_pskel::
  post_valueAttrType ()
  {
  }

  // textType_pskel
  //

  void textType_pskel::
  c ()
  {
  }

  void textType_pskel::
  hod ()
  {
  }

  void textType_pskel::
  o ()
  {
  }

  void textType_pskel::
  j ()
  {
  }

  void textType_pskel::
  vys ()
  {
  }

  void textType_pskel::
  sir ()
  {
  }

  void textType_pskel::
  post_textType ()
  {
  }

  bool textType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "c" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->c_parser_;

      if (this->c_parser_)
        this->c_parser_->pre ();

      return true;
    }

    return false;
  }

  bool textType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "c" && ns.empty ())
    {
      if (this->c_parser_)
      {
        this->c_parser_->post_coordinateType ();
        this->c ();
      }

      return true;
    }

    return false;
  }

  bool textType_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
      return true;

    if (n == "hod" && ns.empty ())
    {
      if (this->hod_parser_)
      {
        this->hod_parser_->pre ();
        this->hod_parser_->_pre_impl ();
        this->hod_parser_->_characters (v);
        this->hod_parser_->_post_impl ();
        this->hod_parser_->post_notEmptyStringType ();
        this->hod ();
      }

      return true;
    }

    if (n == "o" && ns.empty ())
    {
      if (this->o_parser_)
      {
        this->o_parser_->pre ();
        this->o_parser_->_pre_impl ();
        this->o_parser_->_characters (v);
        this->o_parser_->_post_impl ();
        this->o_parser_->post_rotationAttrType ();
        this->o ();
      }

      return true;
    }

    if (n == "j" && ns.empty ())
    {
      if (this->j_parser_)
      {
        this->j_parser_->pre ();
        this->j_parser_->_pre_impl ();
        this->j_parser_->_characters (v);
        this->j_parser_->_post_impl ();
        this->j_parser_->post_justificationAttrType ();
        this->j ();
      }

      return true;
    }

    if (n == "vys" && ns.empty ())
    {
      if (this->vys_parser_)
      {
        this->vys_parser_->pre ();
        this->vys_parser_->_pre_impl ();
        this->vys_parser_->_characters (v);
        this->vys_parser_->_post_impl ();
        this->vys_parser_->post_heightAttrType ();
        this->vys ();
      }

      return true;
    }

    if (n == "sir" && ns.empty ())
    {
      if (this->sir_parser_)
      {
        this->sir_parser_->pre ();
        this->sir_parser_->_pre_impl ();
        this->sir_parser_->_characters (v);
        this->sir_parser_->_post_impl ();
        this->sir_parser_->post_widthAttrType ();
        this->sir ();
      }

      return true;
    }

    return false;
  }

  // cellType_pskel
  //

  void cellType_pskel::
  c ()
  {
  }

  void cellType_pskel::
  o ()
  {
  }

  void cellType_pskel::
  naz ()
  {
  }

  void cellType_pskel::
  post_cellType ()
  {
  }

  bool cellType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "c" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->c_parser_;

      if (this->c_parser_)
        this->c_parser_->pre ();

      return true;
    }

    return false;
  }

  bool cellType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "c" && ns.empty ())
    {
      if (this->c_parser_)
      {
        this->c_parser_->post_coordinateType ();
        this->c ();
      }

      return true;
    }

    return false;
  }

  bool cellType_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
      return true;

    if (n == "o" && ns.empty ())
    {
      if (this->o_parser_)
      {
        this->o_parser_->pre ();
        this->o_parser_->_pre_impl ();
        this->o_parser_->_characters (v);
        this->o_parser_->_post_impl ();
        this->o_parser_->post_rotationAttrType ();
        this->o ();
      }

      return true;
    }

    if (n == "naz" && ns.empty ())
    {
      if (this->naz_parser_)
      {
        this->naz_parser_->pre ();
        this->naz_parser_->_pre_impl ();
        this->naz_parser_->_characters (v);
        this->naz_parser_->_post_impl ();
        this->naz_parser_->post_notEmptyStringType ();
        this->naz ();
      }

      return true;
    }

    return false;
  }

  // cadasterCodeType_pskel
  //

  void cadasterCodeType_pskel::
  post_cadasterCodeType ()
  {
  }

  // lvNumberAttrType_pskel
  //

  void lvNumberAttrType_pskel::
  post_lvNumberAttrType ()
  {
  }

  // numeratorType_pskel
  //

  void numeratorType_pskel::
  post_numeratorType ()
  {
  }

  // denominatorType_pskel
  //

  void denominatorType_pskel::
  post_denominatorType ()
  {
  }

  // areaAttrType_pskel
  //

  void areaAttrType_pskel::
  post_areaAttrType ()
  {
  }

  // priceAttrType_pskel
  //

  void priceAttrType_pskel::
  post_priceAttrType ()
  {
  }

  // distanceType_pskel
  //

  void distanceType_pskel::
  post_distanceType ()
  {
  }

  // notEmptyStringType_pskel
  //

  void notEmptyStringType_pskel::
  post_notEmptyStringType ()
  {
  }

  // opsubIdType_pskel
  //

  void opsubIdType_pskel::
  post_opsubIdType ()
  {
  }

  // bpejType_pskel
  //

  void bpejType_pskel::
  post_bpejType ()
  {
  }

  // bpejCodeAttrType_pskel
  //

  void bpejCodeAttrType_pskel::
  post_bpejCodeAttrType ()
  {
  }

  // birthNumberType_pskel
  //

  void birthNumberType_pskel::
  post_birthNumberType ()
  {
  }

  // streetNumberType_pskel
  //

  void streetNumberType_pskel::
  post_streetNumberType ()
  {
  }

  // orientationNumberType_pskel
  //

  void orientationNumberType_pskel::
  post_orientationNumberType ()
  {
  }

  // postCodeType_pskel
  //

  void postCodeType_pskel::
  post_postCodeType ()
  {
  }

  // emailType_pskel
  //

  void emailType_pskel::
  post_emailType ()
  {
  }

  // icoType_pskel
  //

  void icoType_pskel::
  post_icoType ()
  {
  }

  // koeficientType_pskel
  //

  void koeficientType_pskel::
  post_koeficientType ()
  {
  }

  // participantType_pskel
  //

  void participantType_pskel::
  post_participantType ()
  {
  }

  // basicIdAttrType_pskel
  //

  void basicIdAttrType_pskel::
  post_basicIdAttrType ()
  {
  }

  // kindOfUseAttrType_pskel
  //

  void kindOfUseAttrType_pskel::
  post_kindOfUseAttrType ()
  {
  }

  // kindOfAreaAttrType_pskel
  //

  void kindOfAreaAttrType_pskel::
  post_kindOfAreaAttrType ()
  {
  }

  // basicStringIdAttrType_pskel
  //

  void basicStringIdAttrType_pskel::
  post_basicStringIdAttrType ()
  {
    post_notEmptyStringType ();
  }

  // participantIdAttrType_pskel
  //

  void participantIdAttrType_pskel::
  post_participantIdAttrType ()
  {
  }

  // parcelIdAttrType_pskel
  //

  void parcelIdAttrType_pskel::
  post_parcelIdAttrType ()
  {
    post_basicStringIdAttrType ();
  }

  // noteAttrType_pskel
  //

  void noteAttrType_pskel::
  post_noteAttrType ()
  {
  }

  // outsideParcelType_pskel
  //

  void outsideParcelType_pskel::
  pa ()
  {
  }

  void outsideParcelType_pskel::
  post_outsideParcelType ()
  {
  }

  bool outsideParcelType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "pa" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->pa_parser_;

      if (this->pa_parser_)
        this->pa_parser_->pre ();

      return true;
    }

    return false;
  }

  bool outsideParcelType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "pa" && ns.empty ())
    {
      if (this->pa_parser_)
      {
        this->pa_parser_->post_pa ();
        this->pa ();
      }

      return true;
    }

    return false;
  }

  // newNumberType_pskel
  //

  void newNumberType_pskel::
  vym ()
  {
  }

  void newNumberType_pskel::
  kk ()
  {
  }

  void newNumberType_pskel::
  kcp ()
  {
  }

  void newNumberType_pskel::
  pcp ()
  {
  }

  void newNumberType_pskel::
  dcp ()
  {
  }

  void newNumberType_pskel::
  post_newNumberType ()
  {
  }

  bool newNumberType_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
      return true;

    if (n == "vym" && ns.empty ())
    {
      if (this->vym_parser_)
      {
        this->vym_parser_->pre ();
        this->vym_parser_->_pre_impl ();
        this->vym_parser_->_characters (v);
        this->vym_parser_->_post_impl ();
        this->vym_parser_->post_areaAttrType ();
        this->vym ();
      }

      return true;
    }

    if (n == "kk" && ns.empty ())
    {
      if (this->kk_parser_)
      {
        this->kk_parser_->pre ();
        this->kk_parser_->_pre_impl ();
        this->kk_parser_->_characters (v);
        this->kk_parser_->_post_impl ();
        this->kk_parser_->post_cadasterCodeType ();
        this->kk ();
      }

      return true;
    }

    if (n == "kcp" && ns.empty ())
    {
      if (this->kcp_parser_)
      {
        this->kcp_parser_->pre ();
        this->kcp_parser_->_pre_impl ();
        this->kcp_parser_->_characters (v);
        this->kcp_parser_->_post_impl ();
        this->kcp_parser_->post_parcelNumberAttrType ();
        this->kcp ();
      }

      return true;
    }

    if (n == "pcp" && ns.empty ())
    {
      if (this->pcp_parser_)
      {
        this->pcp_parser_->pre ();
        this->pcp_parser_->_pre_impl ();
        this->pcp_parser_->_characters (v);
        this->pcp_parser_->_post_impl ();
        this->pcp_parser_->post_poddeleniNumberAttrType ();
        this->pcp ();
      }

      return true;
    }

    if (n == "dcp" && ns.empty ())
    {
      if (this->dcp_parser_)
      {
        this->dcp_parser_->pre ();
        this->dcp_parser_->_pre_impl ();
        this->dcp_parser_->_characters (v);
        this->dcp_parser_->_post_impl ();
        this->dcp_parser_->post_druhCislovaniNumberAttrType ();
        this->dcp ();
      }

      return true;
    }

    return false;
  }

  // newNumberCollectionType_pskel
  //

  void newNumberCollectionType_pskel::
  nc ()
  {
  }

  void newNumberCollectionType_pskel::
  post_newNumberCollectionType ()
  {
  }

  bool newNumberCollectionType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "nc" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->nc_parser_;

      if (this->nc_parser_)
        this->nc_parser_->pre ();

      return true;
    }

    return false;
  }

  bool newNumberCollectionType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "nc" && ns.empty ())
    {
      if (this->nc_parser_)
      {
        this->nc_parser_->post_newNumberType ();
        this->nc ();
      }

      return true;
    }

    return false;
  }

  // pneresType_pskel
  //

  void pneresType_pskel::
  pa ()
  {
  }

  void pneresType_pskel::
  post_pneresType ()
  {
  }

  bool pneresType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "pa" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->pa_parser_;

      if (this->pa_parser_)
        this->pa_parser_->pre ();

      return true;
    }

    return false;
  }

  bool pneresType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "pa" && ns.empty ())
    {
      if (this->pa_parser_)
      {
        this->pa_parser_->post_pa1 ();
        this->pa ();
      }

      return true;
    }

    return false;
  }

  // ochrType_pskel
  //

  void ochrType_pskel::
  dil ()
  {
  }

  void ochrType_pskel::
  post_ochrType ()
  {
  }

  bool ochrType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "dil" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->dil_parser_;

      if (this->dil_parser_)
        this->dil_parser_->pre ();

      return true;
    }

    return false;
  }

  bool ochrType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "dil" && ns.empty ())
    {
      if (this->dil_parser_)
      {
        this->dil_parser_->post_dil ();
        this->dil ();
      }

      return true;
    }

    return false;
  }

  // typPravAttrType_pskel
  //

  void typPravAttrType_pskel::
  post_typPravAttrType ()
  {
  }

  // bremenoType_pskel
  //

  void bremenoType_pskel::
  cen ()
  {
  }

  void bremenoType_pskel::
  typ ()
  {
  }

  void bremenoType_pskel::
  popis ()
  {
  }

  void bremenoType_pskel::
  o_pro_id ()
  {
  }

  void bremenoType_pskel::
  p_k_id ()
  {
  }

  void bremenoType_pskel::
  o_k_id ()
  {
  }

  void bremenoType_pskel::
  pn_id ()
  {
  }

  void bremenoType_pskel::
  p_pro_id ()
  {
  }

  void bremenoType_pskel::
  post_bremenoType ()
  {
  }

  bool bremenoType_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
      return true;

    if (n == "cen" && ns.empty ())
    {
      if (this->cen_parser_)
      {
        this->cen_parser_->pre ();
        this->cen_parser_->_pre_impl ();
        this->cen_parser_->_characters (v);
        this->cen_parser_->_post_impl ();
        this->cen_parser_->post_priceAttrType ();
        this->cen ();
      }

      return true;
    }

    if (n == "typ" && ns.empty ())
    {
      if (this->typ_parser_)
      {
        this->typ_parser_->pre ();
        this->typ_parser_->_pre_impl ();
        this->typ_parser_->_characters (v);
        this->typ_parser_->_post_impl ();
        this->typ_parser_->post_typPravAttrType ();
        this->typ ();
      }

      return true;
    }

    if (n == "popis" && ns.empty ())
    {
      if (this->popis_parser_)
      {
        this->popis_parser_->pre ();
        this->popis_parser_->_pre_impl ();
        this->popis_parser_->_characters (v);
        this->popis_parser_->_post_impl ();
        this->popis_parser_->post_notEmptyStringType ();
        this->popis ();
      }

      return true;
    }

    if (n == "o_pro_id" && ns.empty ())
    {
      if (this->o_pro_id_parser_)
      {
        this->o_pro_id_parser_->pre ();
        this->o_pro_id_parser_->_pre_impl ();
        this->o_pro_id_parser_->_characters (v);
        this->o_pro_id_parser_->_post_impl ();
        this->o_pro_id_parser_->post_notEmptyStringType ();
        this->o_pro_id ();
      }

      return true;
    }

    if (n == "p_k_id" && ns.empty ())
    {
      if (this->p_k_id_parser_)
      {
        this->p_k_id_parser_->pre ();
        this->p_k_id_parser_->_pre_impl ();
        this->p_k_id_parser_->_characters (v);
        this->p_k_id_parser_->_post_impl ();
        this->p_k_id_parser_->post_notEmptyStringType ();
        this->p_k_id ();
      }

      return true;
    }

    if (n == "o_k_id" && ns.empty ())
    {
      if (this->o_k_id_parser_)
      {
        this->o_k_id_parser_->pre ();
        this->o_k_id_parser_->_pre_impl ();
        this->o_k_id_parser_->_characters (v);
        this->o_k_id_parser_->_post_impl ();
        this->o_k_id_parser_->post_notEmptyStringType ();
        this->o_k_id ();
      }

      return true;
    }

    if (n == "pn_id" && ns.empty ())
    {
      if (this->pn_id_parser_)
      {
        this->pn_id_parser_->pre ();
        this->pn_id_parser_->_pre_impl ();
        this->pn_id_parser_->_characters (v);
        this->pn_id_parser_->_post_impl ();
        this->pn_id_parser_->post_parcelIdAttrType ();
        this->pn_id ();
      }

      return true;
    }

    if (n == "p_pro_id" && ns.empty ())
    {
      if (this->p_pro_id_parser_)
      {
        this->p_pro_id_parser_->pre ();
        this->p_pro_id_parser_->_pre_impl ();
        this->p_pro_id_parser_->_characters (v);
        this->p_pro_id_parser_->_post_impl ();
        this->p_pro_id_parser_->post_parcelIdAttrType ();
        this->p_pro_id ();
      }

      return true;
    }

    return false;
  }

  // bremCollectionType_pskel
  //

  void bremCollectionType_pskel::
  bre ()
  {
  }

  void bremCollectionType_pskel::
  post_bremCollectionType ()
  {
  }

  bool bremCollectionType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "bre" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->bre_parser_;

      if (this->bre_parser_)
        this->bre_parser_->pre ();

      return true;
    }

    return false;
  }

  bool bremCollectionType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "bre" && ns.empty ())
    {
      if (this->bre_parser_)
      {
        this->bre_parser_->post_bremenoType ();
        this->bre ();
      }

      return true;
    }

    return false;
  }

  // nvlaType_pskel
  //

  void nvlaType_pskel::
  lvn ()
  {
  }

  void nvlaType_pskel::
  kkn ()
  {
  }

  void nvlaType_pskel::
  vymp ()
  {
  }

  void nvlaType_pskel::
  cenp ()
  {
  }

  void nvlaType_pskel::
  vzdp ()
  {
  }

  void nvlaType_pskel::
  op_id ()
  {
  }

  void nvlaType_pskel::
  poz ()
  {
  }

  void nvlaType_pskel::
  post_nvlaType ()
  {
  }

  bool nvlaType_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
      return true;

    if (n == "lvn" && ns.empty ())
    {
      if (this->lvn_parser_)
      {
        this->lvn_parser_->pre ();
        this->lvn_parser_->_pre_impl ();
        this->lvn_parser_->_characters (v);
        this->lvn_parser_->_post_impl ();
        this->lvn_parser_->post_lvNumberAttrType ();
        this->lvn ();
      }

      return true;
    }

    if (n == "kkn" && ns.empty ())
    {
      if (this->kkn_parser_)
      {
        this->kkn_parser_->pre ();
        this->kkn_parser_->_pre_impl ();
        this->kkn_parser_->_characters (v);
        this->kkn_parser_->_post_impl ();
        this->kkn_parser_->post_cadasterCodeType ();
        this->kkn ();
      }

      return true;
    }

    if (n == "vymp" && ns.empty ())
    {
      if (this->vymp_parser_)
      {
        this->vymp_parser_->pre ();
        this->vymp_parser_->_pre_impl ();
        this->vymp_parser_->_characters (v);
        this->vymp_parser_->_post_impl ();
        this->vymp_parser_->post_areaAttrType ();
        this->vymp ();
      }

      return true;
    }

    if (n == "cenp" && ns.empty ())
    {
      if (this->cenp_parser_)
      {
        this->cenp_parser_->pre ();
        this->cenp_parser_->_pre_impl ();
        this->cenp_parser_->_characters (v);
        this->cenp_parser_->_post_impl ();
        this->cenp_parser_->post_priceAttrType ();
        this->cenp ();
      }

      return true;
    }

    if (n == "vzdp" && ns.empty ())
    {
      if (this->vzdp_parser_)
      {
        this->vzdp_parser_->pre ();
        this->vzdp_parser_->_pre_impl ();
        this->vzdp_parser_->_characters (v);
        this->vzdp_parser_->_post_impl ();
        this->vzdp_parser_->post_distanceType ();
        this->vzdp ();
      }

      return true;
    }

    if (n == "op_id" && ns.empty ())
    {
      if (this->op_id_parser_)
      {
        this->op_id_parser_->pre ();
        this->op_id_parser_->_pre_impl ();
        this->op_id_parser_->_characters (v);
        this->op_id_parser_->_post_impl ();
        this->op_id_parser_->post_opsubIdType ();
        this->op_id ();
      }

      return true;
    }

    if (n == "poz" && ns.empty ())
    {
      if (this->poz_parser_)
      {
        this->poz_parser_->pre ();
        this->poz_parser_->_pre_impl ();
        this->poz_parser_->_characters (v);
        this->poz_parser_->_post_impl ();
        this->poz_parser_->post_noteAttrType ();
        this->poz ();
      }

      return true;
    }

    return false;
  }

  // nvlaCollectionType_pskel
  //

  void nvlaCollectionType_pskel::
  nvla ()
  {
  }

  void nvlaCollectionType_pskel::
  post_nvlaCollectionType ()
  {
  }

  bool nvlaCollectionType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "nvla" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->nvla_parser_;

      if (this->nvla_parser_)
        this->nvla_parser_->pre ();

      return true;
    }

    return false;
  }

  bool nvlaCollectionType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "nvla" && ns.empty ())
    {
      if (this->nvla_parser_)
      {
        this->nvla_parser_->post_nvlaType ();
        this->nvla ();
      }

      return true;
    }

    return false;
  }

  // vlaCollectionType_pskel
  //

  void vlaCollectionType_pskel::
  vla ()
  {
  }

  void vlaCollectionType_pskel::
  post_vlaCollectionType ()
  {
  }

  bool vlaCollectionType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "vla" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->vla_parser_;

      if (this->vla_parser_)
        this->vla_parser_->pre ();

      return true;
    }

    return false;
  }

  bool vlaCollectionType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "vla" && ns.empty ())
    {
      if (this->vla_parser_)
      {
        this->vla_parser_->post_vla ();
        this->vla ();
      }

      return true;
    }

    return false;
  }

  // participantReferenceType_pskel
  //

  void participantReferenceType_pskel::
  uc_id ()
  {
  }

  void participantReferenceType_pskel::
  op_id ()
  {
  }

  void participantReferenceType_pskel::
  typ ()
  {
  }

  void participantReferenceType_pskel::
  post_participantReferenceType ()
  {
  }

  bool participantReferenceType_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
      return true;

    if (n == "uc_id" && ns.empty ())
    {
      if (this->uc_id_parser_)
      {
        this->uc_id_parser_->pre ();
        this->uc_id_parser_->_pre_impl ();
        this->uc_id_parser_->_characters (v);
        this->uc_id_parser_->_post_impl ();
        this->uc_id_parser_->post_participantIdAttrType ();
        this->uc_id ();
      }

      return true;
    }

    if (n == "op_id" && ns.empty ())
    {
      if (this->op_id_parser_)
      {
        this->op_id_parser_->pre ();
        this->op_id_parser_->_pre_impl ();
        this->op_id_parser_->_characters (v);
        this->op_id_parser_->_post_impl ();
        this->op_id_parser_->post_opsubIdType ();
        this->op_id ();
      }

      return true;
    }

    if (n == "typ" && ns.empty ())
    {
      if (this->typ_parser_)
      {
        this->typ_parser_->pre ();
        this->typ_parser_->_pre_impl ();
        this->typ_parser_->_characters (v);
        this->typ_parser_->_post_impl ();
        this->typ_parser_->post_participantType ();
        this->typ ();
      }

      return true;
    }

    return false;
  }

  // druhCislovaniNumberAttrType_pskel
  //

  void druhCislovaniNumberAttrType_pskel::
  post_druhCislovaniNumberAttrType ()
  {
  }

  // parcelNumberAttrType_pskel
  //

  void parcelNumberAttrType_pskel::
  post_parcelNumberAttrType ()
  {
  }

  // poddeleniNumberAttrType_pskel
  //

  void poddeleniNumberAttrType_pskel::
  post_poddeleniNumberAttrType ()
  {
  }

  // resAttrType_pskel
  //

  void resAttrType_pskel::
  post_resAttrType ()
  {
  }

  // rusAttrType_pskel
  //

  void rusAttrType_pskel::
  post_rusAttrType ()
  {
  }

  // cirAttrType_pskel
  //

  void cirAttrType_pskel::
  post_cirAttrType ()
  {
  }

  // soucAttrType_pskel
  //

  void soucAttrType_pskel::
  post_soucAttrType ()
  {
  }

  // vysAttrType_pskel
  //

  void vysAttrType_pskel::
  post_vysAttrType ()
  {
  }

  // navrhPhaseType_pskel
  //

  void navrhPhaseType_pskel::
  post_navrhPhaseType ()
  {
  }

  // navrhType_pskel
  //

  void navrhType_pskel::
  lv ()
  {
  }

  void navrhType_pskel::
  fn ()
  {
  }

  void navrhType_pskel::
  dvn (const ::xml_schema::date_time&)
  {
  }

  void navrhType_pskel::
  dvnr (const ::xml_schema::date_time&)
  {
  }

  void navrhType_pskel::
  post_navrhType ()
  {
  }

  bool navrhType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "lv" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->lv_parser_;

      if (this->lv_parser_)
        this->lv_parser_->pre ();

      return true;
    }

    return false;
  }

  bool navrhType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "lv" && ns.empty ())
    {
      if (this->lv_parser_)
      {
        this->lv_parser_->post_lv ();
        this->lv ();
      }

      return true;
    }

    return false;
  }

  bool navrhType_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
      return true;

    if (n == "fn" && ns.empty ())
    {
      if (this->fn_parser_)
      {
        this->fn_parser_->pre ();
        this->fn_parser_->_pre_impl ();
        this->fn_parser_->_characters (v);
        this->fn_parser_->_post_impl ();
        this->fn_parser_->post_navrhPhaseType ();
        this->fn ();
      }

      return true;
    }

    if (n == "dvn" && ns.empty ())
    {
      if (this->dvn_parser_)
      {
        this->dvn_parser_->pre ();
        this->dvn_parser_->_pre_impl ();
        this->dvn_parser_->_characters (v);
        this->dvn_parser_->_post_impl ();
        this->dvn (this->dvn_parser_->post_date_time ());
      }

      return true;
    }

    if (n == "dvnr" && ns.empty ())
    {
      if (this->dvnr_parser_)
      {
        this->dvnr_parser_->pre ();
        this->dvnr_parser_->_pre_impl ();
        this->dvnr_parser_->_characters (v);
        this->dvnr_parser_->_post_impl ();
        this->dvnr (this->dvnr_parser_->post_date_time ());
      }

      return true;
    }

    return false;
  }

  // bpejCollectionType_pskel
  //

  void bpejCollectionType_pskel::
  dil ()
  {
  }

  void bpejCollectionType_pskel::
  post_bpejCollectionType ()
  {
  }

  bool bpejCollectionType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "dil" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->dil_parser_;

      if (this->dil_parser_)
        this->dil_parser_->pre ();

      return true;
    }

    return false;
  }

  bool bpejCollectionType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "dil" && ns.empty ())
    {
      if (this->dil_parser_)
      {
        this->dil_parser_->post_dil1 ();
        this->dil ();
      }

      return true;
    }

    return false;
  }

  // claimBpejCollectionType_pskel
  //

  void claimBpejCollectionType_pskel::
  dil ()
  {
  }

  void claimBpejCollectionType_pskel::
  post_claimBpejCollectionType ()
  {
  }

  bool claimBpejCollectionType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "dil" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->dil_parser_;

      if (this->dil_parser_)
        this->dil_parser_->pre ();

      return true;
    }

    return false;
  }

  bool claimBpejCollectionType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "dil" && ns.empty ())
    {
      if (this->dil_parser_)
      {
        this->dil_parser_->post_dil2 ();
        this->dil ();
      }

      return true;
    }

    return false;
  }

  // areaKindLabelAttrType_pskel
  //

  void areaKindLabelAttrType_pskel::
  post_areaKindLabelAttrType ()
  {
    post_notEmptyStringType ();
  }

  // porostPartTypeBase_pskel
  //

  void porostPartTypeBase_pskel::
  post_porostPartTypeBase ()
  {
  }

  // solPart_pskel
  //

  void solPart_pskel::
  cen ()
  {
  }

  void solPart_pskel::
  naz ()
  {
  }

  void solPart_pskel::
  post_solPart ()
  {
    post_porostPartTypeBase ();
  }

  bool solPart_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::vfp::porostPartTypeBase_pskel::_attribute_impl (ns, n, v))
      return true;

    if (n == "cen" && ns.empty ())
    {
      if (this->cen_parser_)
      {
        this->cen_parser_->pre ();
        this->cen_parser_->_pre_impl ();
        this->cen_parser_->_characters (v);
        this->cen_parser_->_post_impl ();
        this->cen_parser_->post_priceAttrType ();
        this->cen ();
      }

      return true;
    }

    if (n == "naz" && ns.empty ())
    {
      if (this->naz_parser_)
      {
        this->naz_parser_->pre ();
        this->naz_parser_->_pre_impl ();
        this->naz_parser_->_characters (v);
        this->naz_parser_->_post_impl ();
        this->naz_parser_->post_notEmptyStringType ();
        this->naz ();
      }

      return true;
    }

    return false;
  }

  // znaPart_pskel
  //

  void znaPart_pskel::
  cen ()
  {
  }

  void znaPart_pskel::
  post_znaPart ()
  {
    post_porostPartTypeBase ();
  }

  bool znaPart_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::vfp::porostPartTypeBase_pskel::_attribute_impl (ns, n, v))
      return true;

    if (n == "cen" && ns.empty ())
    {
      if (this->cen_parser_)
      {
        this->cen_parser_->pre ();
        this->cen_parser_->_pre_impl ();
        this->cen_parser_->_characters (v);
        this->cen_parser_->_post_impl ();
        this->cen_parser_->post_areaAttrType ();
        this->cen ();
      }

      return true;
    }

    return false;
  }

  // porPart_pskel
  //

  void porPart_pskel::
  dp ()
  {
  }

  void porPart_pskel::
  dpo ()
  {
  }

  void porPart_pskel::
  zv ()
  {
  }

  void porPart_pskel::
  cen ()
  {
  }

  void porPart_pskel::
  vym ()
  {
  }

  void porPart_pskel::
  post_porPart ()
  {
    post_porostPartTypeBase ();
  }

  bool porPart_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::vfp::porostPartTypeBase_pskel::_attribute_impl (ns, n, v))
      return true;

    if (n == "dp" && ns.empty ())
    {
      if (this->dp_parser_)
      {
        this->dp_parser_->pre ();
        this->dp_parser_->_pre_impl ();
        this->dp_parser_->_characters (v);
        this->dp_parser_->_post_impl ();
        this->dp_parser_->post_kindOfAreaAttrType ();
        this->dp ();
      }

      return true;
    }

    if (n == "dpo" && ns.empty ())
    {
      if (this->dpo_parser_)
      {
        this->dpo_parser_->pre ();
        this->dpo_parser_->_pre_impl ();
        this->dpo_parser_->_characters (v);
        this->dpo_parser_->_post_impl ();
        this->dpo_parser_->post_areaKindLabelAttrType ();
        this->dpo ();
      }

      return true;
    }

    if (n == "zv" && ns.empty ())
    {
      if (this->zv_parser_)
      {
        this->zv_parser_->pre ();
        this->zv_parser_->_pre_impl ();
        this->zv_parser_->_characters (v);
        this->zv_parser_->_post_impl ();
        this->zv_parser_->post_kindOfUseAttrType ();
        this->zv ();
      }

      return true;
    }

    if (n == "cen" && ns.empty ())
    {
      if (this->cen_parser_)
      {
        this->cen_parser_->pre ();
        this->cen_parser_->_pre_impl ();
        this->cen_parser_->_characters (v);
        this->cen_parser_->_post_impl ();
        this->cen_parser_->post_priceAttrType ();
        this->cen ();
      }

      return true;
    }

    if (n == "vym" && ns.empty ())
    {
      if (this->vym_parser_)
      {
        this->vym_parser_->pre ();
        this->vym_parser_->_pre_impl ();
        this->vym_parser_->_characters (v);
        this->vym_parser_->_post_impl ();
        this->vym_parser_->post_areaAttrType ();
        this->vym ();
      }

      return true;
    }

    return false;
  }

  // porCollectionType_pskel
  //

  void porCollectionType_pskel::
  dil ()
  {
  }

  void porCollectionType_pskel::
  post_porCollectionType ()
  {
  }

  bool porCollectionType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "dil" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->dil_parser_;

      if (this->dil_parser_)
        this->dil_parser_->pre ();

      return true;
    }

    return false;
  }

  bool porCollectionType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "dil" && ns.empty ())
    {
      if (this->dil_parser_)
      {
        this->dil_parser_->post_porostPartTypeBase ();
        this->dil ();
      }

      return true;
    }

    return false;
  }

  // areaType_pskel
  //

  void areaType_pskel::
  reg ()
  {
  }

  void areaType_pskel::
  t ()
  {
  }

  void areaType_pskel::
  post_areaType ()
  {
  }

  bool areaType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "reg" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->reg_parser_;

      if (this->reg_parser_)
        this->reg_parser_->pre ();

      return true;
    }

    if (n == "t" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->t_parser_;

      if (this->t_parser_)
        this->t_parser_->pre ();

      return true;
    }

    return false;
  }

  bool areaType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "reg" && ns.empty ())
    {
      if (this->reg_parser_)
      {
        this->reg_parser_->post_regionType ();
        this->reg ();
      }

      return true;
    }

    if (n == "t" && ns.empty ())
    {
      if (this->t_parser_)
      {
        this->t_parser_->post_textType ();
        this->t ();
      }

      return true;
    }

    return false;
  }

  // ucaCollectionType_pskel
  //

  void ucaCollectionType_pskel::
  uca ()
  {
  }

  void ucaCollectionType_pskel::
  post_ucaCollectionType ()
  {
  }

  bool ucaCollectionType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "uca" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->uca_parser_;

      if (this->uca_parser_)
        this->uca_parser_->pre ();

      return true;
    }

    return false;
  }

  bool ucaCollectionType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "uca" && ns.empty ())
    {
      if (this->uca_parser_)
      {
        this->uca_parser_->post_participantReferenceType ();
        this->uca ();
      }

      return true;
    }

    return false;
  }

  // gparType_pskel
  //

  void gparType_pskel::
  area ()
  {
  }

  void gparType_pskel::
  post_gparType ()
  {
  }

  bool gparType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "area" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->area_parser_;

      if (this->area_parser_)
        this->area_parser_->pre ();

      return true;
    }

    return false;
  }

  bool gparType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "area" && ns.empty ())
    {
      if (this->area_parser_)
      {
        this->area_parser_->post_areaType ();
        this->area ();
      }

      return true;
    }

    return false;
  }

  // narokType_pskel
  //

  void narokType_pskel::
  lv ()
  {
  }

  void narokType_pskel::
  post_narokType ()
  {
  }

  bool narokType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "lv" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->lv_parser_;

      if (this->lv_parser_)
        this->lv_parser_->pre ();

      return true;
    }

    return false;
  }

  bool narokType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "lv" && ns.empty ())
    {
      if (this->lv_parser_)
      {
        this->lv_parser_->post_lv1 ();
        this->lv ();
      }

      return true;
    }

    return false;
  }

  // ucaType_pskel
  //

  void ucaType_pskel::
  id ()
  {
  }

  void ucaType_pskel::
  op_id ()
  {
  }

  void ucaType_pskel::
  jm (const ::std::string&)
  {
  }

  void ucaType_pskel::
  pr (const ::std::string&)
  {
  }

  void ucaType_pskel::
  naz (const ::std::string&)
  {
  }

  void ucaType_pskel::
  tpj (const ::std::string&)
  {
  }

  void ucaType_pskel::
  tzj (const ::std::string&)
  {
  }

  void ucaType_pskel::
  rc ()
  {
  }

  void ucaType_pskel::
  ico ()
  {
  }

  void ucaType_pskel::
  ul (const ::std::string&)
  {
  }

  void ucaType_pskel::
  cd ()
  {
  }

  void ucaType_pskel::
  co ()
  {
  }

  void ucaType_pskel::
  caob (const ::std::string&)
  {
  }

  void ucaType_pskel::
  mc (const ::std::string&)
  {
  }

  void ucaType_pskel::
  ob (const ::std::string&)
  {
  }

  void ucaType_pskel::
  psc ()
  {
  }

  void ucaType_pskel::
  okr (const ::std::string&)
  {
  }

  void ucaType_pskel::
  sta (const ::std::string&)
  {
  }

  void ucaType_pskel::
  email ()
  {
  }

  void ucaType_pskel::
  tel ()
  {
  }

  void ucaType_pskel::
  post_ucaType ()
  {
  }

  bool ucaType_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
      return true;

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();
        this->id_parser_->_pre_impl ();
        this->id_parser_->_characters (v);
        this->id_parser_->_post_impl ();
        this->id_parser_->post_participantIdAttrType ();
        this->id ();
      }

      return true;
    }

    if (n == "op_id" && ns.empty ())
    {
      if (this->op_id_parser_)
      {
        this->op_id_parser_->pre ();
        this->op_id_parser_->_pre_impl ();
        this->op_id_parser_->_characters (v);
        this->op_id_parser_->_post_impl ();
        this->op_id_parser_->post_opsubIdType ();
        this->op_id ();
      }

      return true;
    }

    if (n == "jm" && ns.empty ())
    {
      if (this->jm_parser_)
      {
        this->jm_parser_->pre ();
        this->jm_parser_->_pre_impl ();
        this->jm_parser_->_characters (v);
        this->jm_parser_->_post_impl ();
        this->jm (this->jm_parser_->post_string ());
      }

      return true;
    }

    if (n == "pr" && ns.empty ())
    {
      if (this->pr_parser_)
      {
        this->pr_parser_->pre ();
        this->pr_parser_->_pre_impl ();
        this->pr_parser_->_characters (v);
        this->pr_parser_->_post_impl ();
        this->pr (this->pr_parser_->post_string ());
      }

      return true;
    }

    if (n == "naz" && ns.empty ())
    {
      if (this->naz_parser_)
      {
        this->naz_parser_->pre ();
        this->naz_parser_->_pre_impl ();
        this->naz_parser_->_characters (v);
        this->naz_parser_->_post_impl ();
        this->naz (this->naz_parser_->post_string ());
      }

      return true;
    }

    if (n == "tpj" && ns.empty ())
    {
      if (this->tpj_parser_)
      {
        this->tpj_parser_->pre ();
        this->tpj_parser_->_pre_impl ();
        this->tpj_parser_->_characters (v);
        this->tpj_parser_->_post_impl ();
        this->tpj (this->tpj_parser_->post_string ());
      }

      return true;
    }

    if (n == "tzj" && ns.empty ())
    {
      if (this->tzj_parser_)
      {
        this->tzj_parser_->pre ();
        this->tzj_parser_->_pre_impl ();
        this->tzj_parser_->_characters (v);
        this->tzj_parser_->_post_impl ();
        this->tzj (this->tzj_parser_->post_string ());
      }

      return true;
    }

    if (n == "rc" && ns.empty ())
    {
      if (this->rc_parser_)
      {
        this->rc_parser_->pre ();
        this->rc_parser_->_pre_impl ();
        this->rc_parser_->_characters (v);
        this->rc_parser_->_post_impl ();
        this->rc_parser_->post_birthNumberType ();
        this->rc ();
      }

      return true;
    }

    if (n == "ico" && ns.empty ())
    {
      if (this->ico_parser_)
      {
        this->ico_parser_->pre ();
        this->ico_parser_->_pre_impl ();
        this->ico_parser_->_characters (v);
        this->ico_parser_->_post_impl ();
        this->ico_parser_->post_icoType ();
        this->ico ();
      }

      return true;
    }

    if (n == "ul" && ns.empty ())
    {
      if (this->ul_parser_)
      {
        this->ul_parser_->pre ();
        this->ul_parser_->_pre_impl ();
        this->ul_parser_->_characters (v);
        this->ul_parser_->_post_impl ();
        this->ul (this->ul_parser_->post_string ());
      }

      return true;
    }

    if (n == "cd" && ns.empty ())
    {
      if (this->cd_parser_)
      {
        this->cd_parser_->pre ();
        this->cd_parser_->_pre_impl ();
        this->cd_parser_->_characters (v);
        this->cd_parser_->_post_impl ();
        this->cd_parser_->post_streetNumberType ();
        this->cd ();
      }

      return true;
    }

    if (n == "co" && ns.empty ())
    {
      if (this->co_parser_)
      {
        this->co_parser_->pre ();
        this->co_parser_->_pre_impl ();
        this->co_parser_->_characters (v);
        this->co_parser_->_post_impl ();
        this->co_parser_->post_orientationNumberType ();
        this->co ();
      }

      return true;
    }

    if (n == "caob" && ns.empty ())
    {
      if (this->caob_parser_)
      {
        this->caob_parser_->pre ();
        this->caob_parser_->_pre_impl ();
        this->caob_parser_->_characters (v);
        this->caob_parser_->_post_impl ();
        this->caob (this->caob_parser_->post_string ());
      }

      return true;
    }

    if (n == "mc" && ns.empty ())
    {
      if (this->mc_parser_)
      {
        this->mc_parser_->pre ();
        this->mc_parser_->_pre_impl ();
        this->mc_parser_->_characters (v);
        this->mc_parser_->_post_impl ();
        this->mc (this->mc_parser_->post_string ());
      }

      return true;
    }

    if (n == "ob" && ns.empty ())
    {
      if (this->ob_parser_)
      {
        this->ob_parser_->pre ();
        this->ob_parser_->_pre_impl ();
        this->ob_parser_->_characters (v);
        this->ob_parser_->_post_impl ();
        this->ob (this->ob_parser_->post_string ());
      }

      return true;
    }

    if (n == "psc" && ns.empty ())
    {
      if (this->psc_parser_)
      {
        this->psc_parser_->pre ();
        this->psc_parser_->_pre_impl ();
        this->psc_parser_->_characters (v);
        this->psc_parser_->_post_impl ();
        this->psc_parser_->post_postCodeType ();
        this->psc ();
      }

      return true;
    }

    if (n == "okr" && ns.empty ())
    {
      if (this->okr_parser_)
      {
        this->okr_parser_->pre ();
        this->okr_parser_->_pre_impl ();
        this->okr_parser_->_characters (v);
        this->okr_parser_->_post_impl ();
        this->okr (this->okr_parser_->post_string ());
      }

      return true;
    }

    if (n == "sta" && ns.empty ())
    {
      if (this->sta_parser_)
      {
        this->sta_parser_->pre ();
        this->sta_parser_->_pre_impl ();
        this->sta_parser_->_characters (v);
        this->sta_parser_->_post_impl ();
        this->sta (this->sta_parser_->post_string ());
      }

      return true;
    }

    if (n == "email" && ns.empty ())
    {
      if (this->email_parser_)
      {
        this->email_parser_->pre ();
        this->email_parser_->_pre_impl ();
        this->email_parser_->_characters (v);
        this->email_parser_->_post_impl ();
        this->email_parser_->post_emailType ();
        this->email ();
      }

      return true;
    }

    if (n == "tel" && ns.empty ())
    {
      if (this->tel_parser_)
      {
        this->tel_parser_->pre ();
        this->tel_parser_->_pre_impl ();
        this->tel_parser_->_characters (v);
        this->tel_parser_->_post_impl ();
        this->tel_parser_->post_notEmptyStringType ();
        this->tel ();
      }

      return true;
    }

    return false;
  }

  // ucastniciType_pskel
  //

  void ucastniciType_pskel::
  uca ()
  {
  }

  void ucastniciType_pskel::
  post_ucastniciType ()
  {
  }

  bool ucastniciType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "uca" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->uca_parser_;

      if (this->uca_parser_)
        this->uca_parser_->pre ();

      return true;
    }

    return false;
  }

  bool ucastniciType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "uca" && ns.empty ())
    {
      if (this->uca_parser_)
      {
        this->uca_parser_->post_ucaType ();
        this->uca ();
      }

      return true;
    }

    return false;
  }

  // graphicElementCodeType_pskel
  //

  void graphicElementCodeType_pskel::
  post_graphicElementCodeType ()
  {
  }

  // mdpType_pskel
  //

  void mdpType_pskel::
  pl ()
  {
  }

  void mdpType_pskel::
  post_mdpType ()
  {
  }

  bool mdpType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "pl" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->pl_parser_;

      if (this->pl_parser_)
        this->pl_parser_->pre ();

      return true;
    }

    return false;
  }

  bool mdpType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "pl" && ns.empty ())
    {
      if (this->pl_parser_)
      {
        this->pl_parser_->post_pl ();
        this->pl ();
      }

      return true;
    }

    return false;
  }

  // plin_pskel
  //

  void plin_pskel::
  lin ()
  {
  }

  void plin_pskel::
  typ ()
  {
  }

  void plin_pskel::
  post_plin ()
  {
  }

  bool plin_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "lin" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->lin_parser_;

      if (this->lin_parser_)
        this->lin_parser_->pre ();

      return true;
    }

    return false;
  }

  bool plin_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "lin" && ns.empty ())
    {
      if (this->lin_parser_)
      {
        this->lin_parser_->post_linearType ();
        this->lin ();
      }

      return true;
    }

    return false;
  }

  bool plin_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
      return true;

    if (n == "typ" && ns.empty ())
    {
      if (this->typ_parser_)
      {
        this->typ_parser_->pre ();
        this->typ_parser_->_pre_impl ();
        this->typ_parser_->_characters (v);
        this->typ_parser_->_post_impl ();
        this->typ_parser_->post_graphicElementCodeType ();
        this->typ ();
      }

      return true;
    }

    return false;
  }

  // pzna_pskel
  //

  void pzna_pskel::
  b ()
  {
  }

  void pzna_pskel::
  typ ()
  {
  }

  void pzna_pskel::
  post_pzna ()
  {
  }

  bool pzna_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "b" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->b_parser_;

      if (this->b_parser_)
        this->b_parser_->pre ();

      return true;
    }

    return false;
  }

  bool pzna_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "b" && ns.empty ())
    {
      if (this->b_parser_)
      {
        this->b_parser_->post_cellType ();
        this->b ();
      }

      return true;
    }

    return false;
  }

  bool pzna_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
      return true;

    if (n == "typ" && ns.empty ())
    {
      if (this->typ_parser_)
      {
        this->typ_parser_->pre ();
        this->typ_parser_->_pre_impl ();
        this->typ_parser_->_characters (v);
        this->typ_parser_->_post_impl ();
        this->typ_parser_->post_graphicElementCodeType ();
        this->typ ();
      }

      return true;
    }

    return false;
  }

  // ptext_pskel
  //

  void ptext_pskel::
  t ()
  {
  }

  void ptext_pskel::
  typ ()
  {
  }

  void ptext_pskel::
  post_ptext ()
  {
  }

  bool ptext_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "t" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->t_parser_;

      if (this->t_parser_)
        this->t_parser_->pre ();

      return true;
    }

    return false;
  }

  bool ptext_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "t" && ns.empty ())
    {
      if (this->t_parser_)
      {
        this->t_parser_->post_textType ();
        this->t ();
      }

      return true;
    }

    return false;
  }

  bool ptext_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
      return true;

    if (n == "typ" && ns.empty ())
    {
      if (this->typ_parser_)
      {
        this->typ_parser_->pre ();
        this->typ_parser_->_pre_impl ();
        this->typ_parser_->_characters (v);
        this->typ_parser_->_post_impl ();
        this->typ_parser_->post_graphicElementCodeType ();
        this->typ ();
      }

      return true;
    }

    return false;
  }

  // parea_pskel
  //

  void parea_pskel::
  reg ()
  {
  }

  void parea_pskel::
  typ ()
  {
  }

  void parea_pskel::
  post_parea ()
  {
  }

  bool parea_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "reg" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->reg_parser_;

      if (this->reg_parser_)
        this->reg_parser_->pre ();

      return true;
    }

    return false;
  }

  bool parea_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "reg" && ns.empty ())
    {
      if (this->reg_parser_)
      {
        this->reg_parser_->post_regionType ();
        this->reg ();
      }

      return true;
    }

    return false;
  }

  bool parea_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
      return true;

    if (n == "typ" && ns.empty ())
    {
      if (this->typ_parser_)
      {
        this->typ_parser_->pre ();
        this->typ_parser_->_pre_impl ();
        this->typ_parser_->_characters (v);
        this->typ_parser_->_post_impl ();
        this->typ_parser_->post_graphicElementCodeType ();
        this->typ ();
      }

      return true;
    }

    return false;
  }

  // psouType_pskel
  //

  void psouType_pskel::
  sx ()
  {
  }

  void psouType_pskel::
  sy ()
  {
  }

  void psouType_pskel::
  sz ()
  {
  }

  void psouType_pskel::
  cb (long long)
  {
  }

  void psouType_pskel::
  post_psouType ()
  {
  }

  bool psouType_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
      return true;

    if (n == "sx" && ns.empty ())
    {
      if (this->sx_parser_)
      {
        this->sx_parser_->pre ();
        this->sx_parser_->_pre_impl ();
        this->sx_parser_->_characters (v);
        this->sx_parser_->_post_impl ();
        this->sx_parser_->post_coordinateAttrType ();
        this->sx ();
      }

      return true;
    }

    if (n == "sy" && ns.empty ())
    {
      if (this->sy_parser_)
      {
        this->sy_parser_->pre ();
        this->sy_parser_->_pre_impl ();
        this->sy_parser_->_characters (v);
        this->sy_parser_->_post_impl ();
        this->sy_parser_->post_coordinateAttrType ();
        this->sy ();
      }

      return true;
    }

    if (n == "sz" && ns.empty ())
    {
      if (this->sz_parser_)
      {
        this->sz_parser_->pre ();
        this->sz_parser_->_pre_impl ();
        this->sz_parser_->_characters (v);
        this->sz_parser_->_post_impl ();
        this->sz_parser_->post_coordinateAttrType ();
        this->sz ();
      }

      return true;
    }

    if (n == "cb" && ns.empty ())
    {
      if (this->cb_parser_)
      {
        this->cb_parser_->pre ();
        this->cb_parser_->_pre_impl ();
        this->cb_parser_->_characters (v);
        this->cb_parser_->_post_impl ();
        this->cb (this->cb_parser_->post_integer ());
      }

      return true;
    }

    return false;
  }

  // zsType_pskel
  //

  void zsType_pskel::
  plins ()
  {
  }

  void zsType_pskel::
  pznas ()
  {
  }

  void zsType_pskel::
  ptexts ()
  {
  }

  void zsType_pskel::
  psour ()
  {
  }

  void zsType_pskel::
  post_zsType ()
  {
  }

  bool zsType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "plins" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->plins_parser_;

      if (this->plins_parser_)
        this->plins_parser_->pre ();

      return true;
    }

    if (n == "pznas" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->pznas_parser_;

      if (this->pznas_parser_)
        this->pznas_parser_->pre ();

      return true;
    }

    if (n == "ptexts" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->ptexts_parser_;

      if (this->ptexts_parser_)
        this->ptexts_parser_->pre ();

      return true;
    }

    if (n == "psour" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->psour_parser_;

      if (this->psour_parser_)
        this->psour_parser_->pre ();

      return true;
    }

    return false;
  }

  bool zsType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "plins" && ns.empty ())
    {
      if (this->plins_parser_)
      {
        this->plins_parser_->post_plins ();
        this->plins ();
      }

      return true;
    }

    if (n == "pznas" && ns.empty ())
    {
      if (this->pznas_parser_)
      {
        this->pznas_parser_->post_pznas ();
        this->pznas ();
      }

      return true;
    }

    if (n == "ptexts" && ns.empty ())
    {
      if (this->ptexts_parser_)
      {
        this->ptexts_parser_->post_ptexts ();
        this->ptexts ();
      }

      return true;
    }

    if (n == "psour" && ns.empty ())
    {
      if (this->psour_parser_)
      {
        this->psour_parser_->post_psour ();
        this->psour ();
      }

      return true;
    }

    return false;
  }

  // pmType_pskel
  //

  void pmType_pskel::
  pmlins ()
  {
  }

  void pmType_pskel::
  pmznas ()
  {
  }

  void pmType_pskel::
  pmtexts ()
  {
  }

  void pmType_pskel::
  pmareas ()
  {
  }

  void pmType_pskel::
  post_pmType ()
  {
  }

  bool pmType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "pmlins" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->pmlins_parser_;

      if (this->pmlins_parser_)
        this->pmlins_parser_->pre ();

      return true;
    }

    if (n == "pmznas" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->pmznas_parser_;

      if (this->pmznas_parser_)
        this->pmznas_parser_->pre ();

      return true;
    }

    if (n == "pmtexts" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->pmtexts_parser_;

      if (this->pmtexts_parser_)
        this->pmtexts_parser_->pre ();

      return true;
    }

    if (n == "pmareas" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->pmareas_parser_;

      if (this->pmareas_parser_)
        this->pmareas_parser_->pre ();

      return true;
    }

    return false;
  }

  bool pmType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "pmlins" && ns.empty ())
    {
      if (this->pmlins_parser_)
      {
        this->pmlins_parser_->post_pmlins ();
        this->pmlins ();
      }

      return true;
    }

    if (n == "pmznas" && ns.empty ())
    {
      if (this->pmznas_parser_)
      {
        this->pmznas_parser_->post_pmznas ();
        this->pmznas ();
      }

      return true;
    }

    if (n == "pmtexts" && ns.empty ())
    {
      if (this->pmtexts_parser_)
      {
        this->pmtexts_parser_->post_pmtexts ();
        this->pmtexts ();
      }

      return true;
    }

    if (n == "pmareas" && ns.empty ())
    {
      if (this->pmareas_parser_)
      {
        this->pmareas_parser_->post_pmareas ();
        this->pmareas ();
      }

      return true;
    }

    return false;
  }

  // mpType_pskel
  //

  void mpType_pskel::
  mplins ()
  {
  }

  void mpType_pskel::
  mpznas ()
  {
  }

  void mpType_pskel::
  mptexts ()
  {
  }

  void mpType_pskel::
  mpareas ()
  {
  }

  void mpType_pskel::
  post_mpType ()
  {
  }

  bool mpType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "mplins" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->mplins_parser_;

      if (this->mplins_parser_)
        this->mplins_parser_->pre ();

      return true;
    }

    if (n == "mpznas" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->mpznas_parser_;

      if (this->mpznas_parser_)
        this->mpznas_parser_->pre ();

      return true;
    }

    if (n == "mptexts" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->mptexts_parser_;

      if (this->mptexts_parser_)
        this->mptexts_parser_->pre ();

      return true;
    }

    if (n == "mpareas" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->mpareas_parser_;

      if (this->mpareas_parser_)
        this->mpareas_parser_->pre ();

      return true;
    }

    return false;
  }

  bool mpType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "mplins" && ns.empty ())
    {
      if (this->mplins_parser_)
      {
        this->mplins_parser_->post_mplins ();
        this->mplins ();
      }

      return true;
    }

    if (n == "mpznas" && ns.empty ())
    {
      if (this->mpznas_parser_)
      {
        this->mpznas_parser_->post_mpznas ();
        this->mpznas ();
      }

      return true;
    }

    if (n == "mptexts" && ns.empty ())
    {
      if (this->mptexts_parser_)
      {
        this->mptexts_parser_->post_mptexts ();
        this->mptexts ();
      }

      return true;
    }

    if (n == "mpareas" && ns.empty ())
    {
      if (this->mpareas_parser_)
      {
        this->mpareas_parser_->post_mpareas ();
        this->mpareas ();
      }

      return true;
    }

    return false;
  }

  // meosType_pskel
  //

  void meosType_pskel::
  meoslins ()
  {
  }

  void meosType_pskel::
  meosznas ()
  {
  }

  void meosType_pskel::
  meostexts ()
  {
  }

  void meosType_pskel::
  meosareas ()
  {
  }

  void meosType_pskel::
  post_meosType ()
  {
  }

  bool meosType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "meoslins" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->meoslins_parser_;

      if (this->meoslins_parser_)
        this->meoslins_parser_->pre ();

      return true;
    }

    if (n == "meosznas" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->meosznas_parser_;

      if (this->meosznas_parser_)
        this->meosznas_parser_->pre ();

      return true;
    }

    if (n == "meostexts" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->meostexts_parser_;

      if (this->meostexts_parser_)
        this->meostexts_parser_->pre ();

      return true;
    }

    if (n == "meosareas" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->meosareas_parser_;

      if (this->meosareas_parser_)
        this->meosareas_parser_->pre ();

      return true;
    }

    return false;
  }

  bool meosType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "meoslins" && ns.empty ())
    {
      if (this->meoslins_parser_)
      {
        this->meoslins_parser_->post_meoslins ();
        this->meoslins ();
      }

      return true;
    }

    if (n == "meosznas" && ns.empty ())
    {
      if (this->meosznas_parser_)
      {
        this->meosznas_parser_->post_meosznas ();
        this->meosznas ();
      }

      return true;
    }

    if (n == "meostexts" && ns.empty ())
    {
      if (this->meostexts_parser_)
      {
        this->meostexts_parser_->post_meostexts ();
        this->meostexts ();
      }

      return true;
    }

    if (n == "meosareas" && ns.empty ())
    {
      if (this->meosareas_parser_)
      {
        this->meosareas_parser_->post_meosareas ();
        this->meosareas ();
      }

      return true;
    }

    return false;
  }

  // meonType_pskel
  //

  void meonType_pskel::
  meonlins ()
  {
  }

  void meonType_pskel::
  meonznas ()
  {
  }

  void meonType_pskel::
  meontexts ()
  {
  }

  void meonType_pskel::
  meonareas ()
  {
  }

  void meonType_pskel::
  post_meonType ()
  {
  }

  bool meonType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "meonlins" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->meonlins_parser_;

      if (this->meonlins_parser_)
        this->meonlins_parser_->pre ();

      return true;
    }

    if (n == "meonznas" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->meonznas_parser_;

      if (this->meonznas_parser_)
        this->meonznas_parser_->pre ();

      return true;
    }

    if (n == "meontexts" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->meontexts_parser_;

      if (this->meontexts_parser_)
        this->meontexts_parser_->pre ();

      return true;
    }

    if (n == "meonareas" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->meonareas_parser_;

      if (this->meonareas_parser_)
        this->meonareas_parser_->pre ();

      return true;
    }

    return false;
  }

  bool meonType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "meonlins" && ns.empty ())
    {
      if (this->meonlins_parser_)
      {
        this->meonlins_parser_->post_meonlins ();
        this->meonlins ();
      }

      return true;
    }

    if (n == "meonznas" && ns.empty ())
    {
      if (this->meonznas_parser_)
      {
        this->meonznas_parser_->post_meonznas ();
        this->meonznas ();
      }

      return true;
    }

    if (n == "meontexts" && ns.empty ())
    {
      if (this->meontexts_parser_)
      {
        this->meontexts_parser_->post_meontexts ();
        this->meontexts ();
      }

      return true;
    }

    if (n == "meonareas" && ns.empty ())
    {
      if (this->meonareas_parser_)
      {
        this->meonareas_parser_->post_meonareas ();
        this->meonareas ();
      }

      return true;
    }

    return false;
  }

  // hvpszType_pskel
  //

  void hvpszType_pskel::
  hvpszlins ()
  {
  }

  void hvpszType_pskel::
  hvpszznas ()
  {
  }

  void hvpszType_pskel::
  hvpsztexts ()
  {
  }

  void hvpszType_pskel::
  hvpszareas ()
  {
  }

  void hvpszType_pskel::
  post_hvpszType ()
  {
  }

  bool hvpszType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "hvpszlins" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->hvpszlins_parser_;

      if (this->hvpszlins_parser_)
        this->hvpszlins_parser_->pre ();

      return true;
    }

    if (n == "hvpszznas" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->hvpszznas_parser_;

      if (this->hvpszznas_parser_)
        this->hvpszznas_parser_->pre ();

      return true;
    }

    if (n == "hvpsztexts" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->hvpsztexts_parser_;

      if (this->hvpsztexts_parser_)
        this->hvpsztexts_parser_->pre ();

      return true;
    }

    if (n == "hvpszareas" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->hvpszareas_parser_;

      if (this->hvpszareas_parser_)
        this->hvpszareas_parser_->pre ();

      return true;
    }

    return false;
  }

  bool hvpszType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "hvpszlins" && ns.empty ())
    {
      if (this->hvpszlins_parser_)
      {
        this->hvpszlins_parser_->post_hvpszlins ();
        this->hvpszlins ();
      }

      return true;
    }

    if (n == "hvpszznas" && ns.empty ())
    {
      if (this->hvpszznas_parser_)
      {
        this->hvpszznas_parser_->post_hvpszznas ();
        this->hvpszznas ();
      }

      return true;
    }

    if (n == "hvpsztexts" && ns.empty ())
    {
      if (this->hvpsztexts_parser_)
      {
        this->hvpsztexts_parser_->post_hvpsztexts ();
        this->hvpsztexts ();
      }

      return true;
    }

    if (n == "hvpszareas" && ns.empty ())
    {
      if (this->hvpszareas_parser_)
      {
        this->hvpszareas_parser_->post_hvpszareas ();
        this->hvpszareas ();
      }

      return true;
    }

    return false;
  }

  // zvbodsType_pskel
  //

  void zvbodsType_pskel::
  zvbod ()
  {
  }

  void zvbodsType_pskel::
  post_zvbodsType ()
  {
  }

  bool zvbodsType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "zvbod" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->zvbod_parser_;

      if (this->zvbod_parser_)
        this->zvbod_parser_->pre ();

      return true;
    }

    return false;
  }

  bool zvbodsType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "zvbod" && ns.empty ())
    {
      if (this->zvbod_parser_)
      {
        this->zvbod_parser_->post_zvbod ();
        this->zvbod ();
      }

      return true;
    }

    return false;
  }

  // zvlinsType_pskel
  //

  void zvlinsType_pskel::
  zvlin ()
  {
  }

  void zvlinsType_pskel::
  post_zvlinsType ()
  {
  }

  bool zvlinsType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "zvlin" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->zvlin_parser_;

      if (this->zvlin_parser_)
        this->zvlin_parser_->pre ();

      return true;
    }

    return false;
  }

  bool zvlinsType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "zvlin" && ns.empty ())
    {
      if (this->zvlin_parser_)
      {
        this->zvlin_parser_->post_zvlin ();
        this->zvlin ();
      }

      return true;
    }

    return false;
  }

  // zvareasType_pskel
  //

  void zvareasType_pskel::
  zvarea ()
  {
  }

  void zvareasType_pskel::
  post_zvareasType ()
  {
  }

  bool zvareasType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "zvarea" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->zvarea_parser_;

      if (this->zvarea_parser_)
        this->zvarea_parser_->pre ();

      return true;
    }

    return false;
  }

  bool zvareasType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "zvarea" && ns.empty ())
    {
      if (this->zvarea_parser_)
      {
        this->zvarea_parser_->post_zvarea ();
        this->zvarea ();
      }

      return true;
    }

    return false;
  }

  // souType_pskel
  //

  void souType_pskel::
  sx ()
  {
  }

  void souType_pskel::
  sy ()
  {
  }

  void souType_pskel::
  cb (long long)
  {
  }

  void souType_pskel::
  kk (long long)
  {
  }

  void souType_pskel::
  ps ()
  {
  }

  void souType_pskel::
  vys ()
  {
  }

  void souType_pskel::
  post_souType ()
  {
  }

  bool souType_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
      return true;

    if (n == "sx" && ns.empty ())
    {
      if (this->sx_parser_)
      {
        this->sx_parser_->pre ();
        this->sx_parser_->_pre_impl ();
        this->sx_parser_->_characters (v);
        this->sx_parser_->_post_impl ();
        this->sx_parser_->post_coordinateAttrType ();
        this->sx ();
      }

      return true;
    }

    if (n == "sy" && ns.empty ())
    {
      if (this->sy_parser_)
      {
        this->sy_parser_->pre ();
        this->sy_parser_->_pre_impl ();
        this->sy_parser_->_characters (v);
        this->sy_parser_->_post_impl ();
        this->sy_parser_->post_coordinateAttrType ();
        this->sy ();
      }

      return true;
    }

    if (n == "cb" && ns.empty ())
    {
      if (this->cb_parser_)
      {
        this->cb_parser_->pre ();
        this->cb_parser_->_pre_impl ();
        this->cb_parser_->_characters (v);
        this->cb_parser_->_post_impl ();
        this->cb (this->cb_parser_->post_integer ());
      }

      return true;
    }

    if (n == "kk" && ns.empty ())
    {
      if (this->kk_parser_)
      {
        this->kk_parser_->pre ();
        this->kk_parser_->_pre_impl ();
        this->kk_parser_->_characters (v);
        this->kk_parser_->_post_impl ();
        this->kk (this->kk_parser_->post_integer ());
      }

      return true;
    }

    if (n == "ps" && ns.empty ())
    {
      if (this->ps_parser_)
      {
        this->ps_parser_->pre ();
        this->ps_parser_->_pre_impl ();
        this->ps_parser_->_characters (v);
        this->ps_parser_->_post_impl ();
        this->ps_parser_->post_notEmptyStringType ();
        this->ps ();
      }

      return true;
    }

    if (n == "vys" && ns.empty ())
    {
      if (this->vys_parser_)
      {
        this->vys_parser_->pre ();
        this->vys_parser_->_pre_impl ();
        this->vys_parser_->_characters (v);
        this->vys_parser_->_post_impl ();
        this->vys_parser_->post_vysAttrType ();
        this->vys ();
      }

      return true;
    }

    return false;
  }

  // opuType_pskel
  //

  void opuType_pskel::
  pl ()
  {
  }

  void opuType_pskel::
  post_opuType ()
  {
  }

  bool opuType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "pl" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->pl_parser_;

      if (this->pl_parser_)
        this->pl_parser_->pre ();

      return true;
    }

    return false;
  }

  bool opuType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "pl" && ns.empty ())
    {
      if (this->pl_parser_)
      {
        this->pl_parser_->post_pl1 ();
        this->pl ();
      }

      return true;
    }

    return false;
  }

  // porostType_pskel
  //

  void porostType_pskel::
  post_porostType ()
  {
  }

  // sol_pskel
  //

  void sol_pskel::
  b ()
  {
  }

  void sol_pskel::
  cen ()
  {
  }

  void sol_pskel::
  naz (const ::std::string&)
  {
  }

  void sol_pskel::
  id ()
  {
  }

  void sol_pskel::
  post_sol ()
  {
    post_porostType ();
  }

  bool sol_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::vfp::porostType_pskel::_start_element_impl (ns, n, t))
      return true;

    if (n == "b" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->b_parser_;

      if (this->b_parser_)
        this->b_parser_->pre ();

      return true;
    }

    return false;
  }

  bool sol_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::vfp::porostType_pskel::_end_element_impl (ns, n))
      return true;

    if (n == "b" && ns.empty ())
    {
      if (this->b_parser_)
      {
        this->b_parser_->post_cellType ();
        this->b ();
      }

      return true;
    }

    return false;
  }

  bool sol_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::vfp::porostType_pskel::_attribute_impl (ns, n, v))
      return true;

    if (n == "cen" && ns.empty ())
    {
      if (this->cen_parser_)
      {
        this->cen_parser_->pre ();
        this->cen_parser_->_pre_impl ();
        this->cen_parser_->_characters (v);
        this->cen_parser_->_post_impl ();
        this->cen_parser_->post_priceAttrType ();
        this->cen ();
      }

      return true;
    }

    if (n == "naz" && ns.empty ())
    {
      if (this->naz_parser_)
      {
        this->naz_parser_->pre ();
        this->naz_parser_->_pre_impl ();
        this->naz_parser_->_characters (v);
        this->naz_parser_->_post_impl ();
        this->naz (this->naz_parser_->post_string ());
      }

      return true;
    }

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();
        this->id_parser_->_pre_impl ();
        this->id_parser_->_characters (v);
        this->id_parser_->_post_impl ();
        this->id_parser_->post_basicIdAttrType ();
        this->id ();
      }

      return true;
    }

    return false;
  }

  // por_pskel
  //

  void por_pskel::
  area ()
  {
  }

  void por_pskel::
  dp ()
  {
  }

  void por_pskel::
  dpo ()
  {
  }

  void por_pskel::
  zv ()
  {
  }

  void por_pskel::
  cen ()
  {
  }

  void por_pskel::
  id ()
  {
  }

  void por_pskel::
  post_por ()
  {
    post_porostType ();
  }

  bool por_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::vfp::porostType_pskel::_start_element_impl (ns, n, t))
      return true;

    if (n == "area" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->area_parser_;

      if (this->area_parser_)
        this->area_parser_->pre ();

      return true;
    }

    return false;
  }

  bool por_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::vfp::porostType_pskel::_end_element_impl (ns, n))
      return true;

    if (n == "area" && ns.empty ())
    {
      if (this->area_parser_)
      {
        this->area_parser_->post_areaType ();
        this->area ();
      }

      return true;
    }

    return false;
  }

  bool por_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::vfp::porostType_pskel::_attribute_impl (ns, n, v))
      return true;

    if (n == "dp" && ns.empty ())
    {
      if (this->dp_parser_)
      {
        this->dp_parser_->pre ();
        this->dp_parser_->_pre_impl ();
        this->dp_parser_->_characters (v);
        this->dp_parser_->_post_impl ();
        this->dp_parser_->post_kindOfAreaAttrType ();
        this->dp ();
      }

      return true;
    }

    if (n == "dpo" && ns.empty ())
    {
      if (this->dpo_parser_)
      {
        this->dpo_parser_->pre ();
        this->dpo_parser_->_pre_impl ();
        this->dpo_parser_->_characters (v);
        this->dpo_parser_->_post_impl ();
        this->dpo_parser_->post_areaKindLabelAttrType ();
        this->dpo ();
      }

      return true;
    }

    if (n == "zv" && ns.empty ())
    {
      if (this->zv_parser_)
      {
        this->zv_parser_->pre ();
        this->zv_parser_->_pre_impl ();
        this->zv_parser_->_characters (v);
        this->zv_parser_->_post_impl ();
        this->zv_parser_->post_kindOfUseAttrType ();
        this->zv ();
      }

      return true;
    }

    if (n == "cen" && ns.empty ())
    {
      if (this->cen_parser_)
      {
        this->cen_parser_->pre ();
        this->cen_parser_->_pre_impl ();
        this->cen_parser_->_characters (v);
        this->cen_parser_->_post_impl ();
        this->cen_parser_->post_priceAttrType ();
        this->cen ();
      }

      return true;
    }

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();
        this->id_parser_->_pre_impl ();
        this->id_parser_->_characters (v);
        this->id_parser_->_post_impl ();
        this->id_parser_->post_basicIdAttrType ();
        this->id ();
      }

      return true;
    }

    return false;
  }

  // stageType_pskel
  //

  void stageType_pskel::
  post_stageType ()
  {
  }

  // landConsType_pskel
  //

  void landConsType_pskel::
  post_landConsType ()
  {
  }

  // ocvType_pskel
  //

  void ocvType_pskel::
  post_ocvType ()
  {
  }

  // versionType_pskel
  //

  void versionType_pskel::
  post_versionType ()
  {
  }

  // headerType_pskel
  //

  void headerType_pskel::
  dvz (const ::xml_schema::date_time&)
  {
  }

  void headerType_pskel::
  dkn (const ::xml_schema::date_time&)
  {
  }

  void headerType_pskel::
  aut ()
  {
  }

  void headerType_pskel::
  et ()
  {
  }

  void headerType_pskel::
  kk ()
  {
  }

  void headerType_pskel::
  typ ()
  {
  }

  void headerType_pskel::
  cpu (unsigned long long)
  {
  }

  void headerType_pskel::
  ocv ()
  {
  }

  void headerType_pskel::
  kv ()
  {
  }

  void headerType_pskel::
  ksz ()
  {
  }

  void headerType_pskel::
  ver ()
  {
  }

  void headerType_pskel::
  sw ()
  {
  }

  void headerType_pskel::
  sx ()
  {
  }

  void headerType_pskel::
  sy ()
  {
  }

  void headerType_pskel::
  post_headerType ()
  {
  }

  bool headerType_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
      return true;

    if (n == "dvz" && ns.empty ())
    {
      if (this->dvz_parser_)
      {
        this->dvz_parser_->pre ();
        this->dvz_parser_->_pre_impl ();
        this->dvz_parser_->_characters (v);
        this->dvz_parser_->_post_impl ();
        this->dvz (this->dvz_parser_->post_date_time ());
      }

      return true;
    }

    if (n == "dkn" && ns.empty ())
    {
      if (this->dkn_parser_)
      {
        this->dkn_parser_->pre ();
        this->dkn_parser_->_pre_impl ();
        this->dkn_parser_->_characters (v);
        this->dkn_parser_->_post_impl ();
        this->dkn (this->dkn_parser_->post_date_time ());
      }

      return true;
    }

    if (n == "aut" && ns.empty ())
    {
      if (this->aut_parser_)
      {
        this->aut_parser_->pre ();
        this->aut_parser_->_pre_impl ();
        this->aut_parser_->_characters (v);
        this->aut_parser_->_post_impl ();
        this->aut_parser_->post_notEmptyStringType ();
        this->aut ();
      }

      return true;
    }

    if (n == "et" && ns.empty ())
    {
      if (this->et_parser_)
      {
        this->et_parser_->pre ();
        this->et_parser_->_pre_impl ();
        this->et_parser_->_characters (v);
        this->et_parser_->_post_impl ();
        this->et_parser_->post_stageType ();
        this->et ();
      }

      return true;
    }

    if (n == "kk" && ns.empty ())
    {
      if (this->kk_parser_)
      {
        this->kk_parser_->pre ();
        this->kk_parser_->_pre_impl ();
        this->kk_parser_->_characters (v);
        this->kk_parser_->_post_impl ();
        this->kk_parser_->post_cadasterCodeType ();
        this->kk ();
      }

      return true;
    }

    if (n == "typ" && ns.empty ())
    {
      if (this->typ_parser_)
      {
        this->typ_parser_->pre ();
        this->typ_parser_->_pre_impl ();
        this->typ_parser_->_characters (v);
        this->typ_parser_->_post_impl ();
        this->typ_parser_->post_landConsType ();
        this->typ ();
      }

      return true;
    }

    if (n == "cpu" && ns.empty ())
    {
      if (this->cpu_parser_)
      {
        this->cpu_parser_->pre ();
        this->cpu_parser_->_pre_impl ();
        this->cpu_parser_->_characters (v);
        this->cpu_parser_->_post_impl ();
        this->cpu (this->cpu_parser_->post_positive_integer ());
      }

      return true;
    }

    if (n == "ocv" && ns.empty ())
    {
      if (this->ocv_parser_)
      {
        this->ocv_parser_->pre ();
        this->ocv_parser_->_pre_impl ();
        this->ocv_parser_->_characters (v);
        this->ocv_parser_->_post_impl ();
        this->ocv_parser_->post_ocvType ();
        this->ocv ();
      }

      return true;
    }

    if (n == "kv" && ns.empty ())
    {
      if (this->kv_parser_)
      {
        this->kv_parser_->pre ();
        this->kv_parser_->_pre_impl ();
        this->kv_parser_->_characters (v);
        this->kv_parser_->_post_impl ();
        this->kv_parser_->post_koeficientType ();
        this->kv ();
      }

      return true;
    }

    if (n == "ksz" && ns.empty ())
    {
      if (this->ksz_parser_)
      {
        this->ksz_parser_->pre ();
        this->ksz_parser_->_pre_impl ();
        this->ksz_parser_->_characters (v);
        this->ksz_parser_->_post_impl ();
        this->ksz_parser_->post_koeficientType ();
        this->ksz ();
      }

      return true;
    }

    if (n == "ver" && ns.empty ())
    {
      if (this->ver_parser_)
      {
        this->ver_parser_->pre ();
        this->ver_parser_->_pre_impl ();
        this->ver_parser_->_characters (v);
        this->ver_parser_->_post_impl ();
        this->ver_parser_->post_versionType ();
        this->ver ();
      }

      return true;
    }

    if (n == "sw" && ns.empty ())
    {
      if (this->sw_parser_)
      {
        this->sw_parser_->pre ();
        this->sw_parser_->_pre_impl ();
        this->sw_parser_->_characters (v);
        this->sw_parser_->_post_impl ();
        this->sw_parser_->post_notEmptyStringType ();
        this->sw ();
      }

      return true;
    }

    if (n == "sx" && ns.empty ())
    {
      if (this->sx_parser_)
      {
        this->sx_parser_->pre ();
        this->sx_parser_->_pre_impl ();
        this->sx_parser_->_characters (v);
        this->sx_parser_->_post_impl ();
        this->sx_parser_->post_coordinateAttrType ();
        this->sx ();
      }

      return true;
    }

    if (n == "sy" && ns.empty ())
    {
      if (this->sy_parser_)
      {
        this->sy_parser_->pre ();
        this->sy_parser_->_pre_impl ();
        this->sy_parser_->_characters (v);
        this->sy_parser_->_post_impl ();
        this->sy_parser_->post_coordinateAttrType ();
        this->sy ();
      }

      return true;
    }

    return false;
  }

  // pbremCollectionType_pskel
  //

  void pbremCollectionType_pskel::
  pl ()
  {
  }

  void pbremCollectionType_pskel::
  post_pbremCollectionType ()
  {
  }

  bool pbremCollectionType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "pl" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->pl_parser_;

      if (this->pl_parser_)
        this->pl_parser_->pre ();

      return true;
    }

    return false;
  }

  bool pbremCollectionType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "pl" && ns.empty ())
    {
      if (this->pl_parser_)
      {
        this->pl_parser_->post_pl2 ();
        this->pl ();
      }

      return true;
    }

    return false;
  }

  // spozCollectionType_pskel
  //

  void spozCollectionType_pskel::
  pl ()
  {
  }

  void spozCollectionType_pskel::
  post_spozCollectionType ()
  {
  }

  bool spozCollectionType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "pl" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->pl_parser_;

      if (this->pl_parser_)
        this->pl_parser_->pre ();

      return true;
    }

    return false;
  }

  bool spozCollectionType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "pl" && ns.empty ())
    {
      if (this->pl_parser_)
      {
        this->pl_parser_->post_pl3 ();
        this->pl ();
      }

      return true;
    }

    return false;
  }

  // vfpType_pskel
  //

  void vfpType_pskel::
  hlav ()
  {
  }

  void vfpType_pskel::
  ucastnici ()
  {
  }

  void vfpType_pskel::
  narok ()
  {
  }

  void vfpType_pskel::
  navrh ()
  {
  }

  void vfpType_pskel::
  pneres ()
  {
  }

  void vfpType_pskel::
  pmimo ()
  {
  }

  void vfpType_pskel::
  bpej ()
  {
  }

  void vfpType_pskel::
  bpejr2 ()
  {
  }

  void vfpType_pskel::
  mdp ()
  {
  }

  void vfpType_pskel::
  zs ()
  {
  }

  void vfpType_pskel::
  opu ()
  {
  }

  void vfpType_pskel::
  por ()
  {
  }

  void vfpType_pskel::
  pbre ()
  {
  }

  void vfpType_pskel::
  spoz ()
  {
  }

  void vfpType_pskel::
  pm ()
  {
  }

  void vfpType_pskel::
  mp ()
  {
  }

  void vfpType_pskel::
  meos ()
  {
  }

  void vfpType_pskel::
  meon ()
  {
  }

  void vfpType_pskel::
  hvpsz ()
  {
  }

  void vfpType_pskel::
  zv ()
  {
  }

  void vfpType_pskel::
  post_vfpType ()
  {
  }

  bool vfpType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "hlav" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->hlav_parser_;

      if (this->hlav_parser_)
        this->hlav_parser_->pre ();

      return true;
    }

    if (n == "ucastnici" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->ucastnici_parser_;

      if (this->ucastnici_parser_)
        this->ucastnici_parser_->pre ();

      return true;
    }

    if (n == "narok" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->narok_parser_;

      if (this->narok_parser_)
        this->narok_parser_->pre ();

      return true;
    }

    if (n == "navrh" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->navrh_parser_;

      if (this->navrh_parser_)
        this->navrh_parser_->pre ();

      return true;
    }

    if (n == "pneres" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->pneres_parser_;

      if (this->pneres_parser_)
        this->pneres_parser_->pre ();

      return true;
    }

    if (n == "pmimo" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->pmimo_parser_;

      if (this->pmimo_parser_)
        this->pmimo_parser_->pre ();

      return true;
    }

    if (n == "bpej" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->bpej_parser_;

      if (this->bpej_parser_)
        this->bpej_parser_->pre ();

      return true;
    }

    if (n == "bpejr2" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->bpejr2_parser_;

      if (this->bpejr2_parser_)
        this->bpejr2_parser_->pre ();

      return true;
    }

    if (n == "mdp" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->mdp_parser_;

      if (this->mdp_parser_)
        this->mdp_parser_->pre ();

      return true;
    }

    if (n == "zs" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->zs_parser_;

      if (this->zs_parser_)
        this->zs_parser_->pre ();

      return true;
    }

    if (n == "opu" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->opu_parser_;

      if (this->opu_parser_)
        this->opu_parser_->pre ();

      return true;
    }

    if (n == "por" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->por_parser_;

      if (this->por_parser_)
        this->por_parser_->pre ();

      return true;
    }

    if (n == "pbre" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->pbre_parser_;

      if (this->pbre_parser_)
        this->pbre_parser_->pre ();

      return true;
    }

    if (n == "spoz" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->spoz_parser_;

      if (this->spoz_parser_)
        this->spoz_parser_->pre ();

      return true;
    }

    if (n == "pm" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->pm_parser_;

      if (this->pm_parser_)
        this->pm_parser_->pre ();

      return true;
    }

    if (n == "mp" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->mp_parser_;

      if (this->mp_parser_)
        this->mp_parser_->pre ();

      return true;
    }

    if (n == "meos" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->meos_parser_;

      if (this->meos_parser_)
        this->meos_parser_->pre ();

      return true;
    }

    if (n == "meon" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->meon_parser_;

      if (this->meon_parser_)
        this->meon_parser_->pre ();

      return true;
    }

    if (n == "hvpsz" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->hvpsz_parser_;

      if (this->hvpsz_parser_)
        this->hvpsz_parser_->pre ();

      return true;
    }

    if (n == "zv" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->zv_parser_;

      if (this->zv_parser_)
        this->zv_parser_->pre ();

      return true;
    }

    return false;
  }

  bool vfpType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "hlav" && ns.empty ())
    {
      if (this->hlav_parser_)
      {
        this->hlav_parser_->post_headerType ();
        this->hlav ();
      }

      return true;
    }

    if (n == "ucastnici" && ns.empty ())
    {
      if (this->ucastnici_parser_)
      {
        this->ucastnici_parser_->post_ucastniciType ();
        this->ucastnici ();
      }

      return true;
    }

    if (n == "narok" && ns.empty ())
    {
      if (this->narok_parser_)
      {
        this->narok_parser_->post_narokType ();
        this->narok ();
      }

      return true;
    }

    if (n == "navrh" && ns.empty ())
    {
      if (this->navrh_parser_)
      {
        this->navrh_parser_->post_navrhType ();
        this->navrh ();
      }

      return true;
    }

    if (n == "pneres" && ns.empty ())
    {
      if (this->pneres_parser_)
      {
        this->pneres_parser_->post_pneresType ();
        this->pneres ();
      }

      return true;
    }

    if (n == "pmimo" && ns.empty ())
    {
      if (this->pmimo_parser_)
      {
        this->pmimo_parser_->post_outsideParcelType ();
        this->pmimo ();
      }

      return true;
    }

    if (n == "bpej" && ns.empty ())
    {
      if (this->bpej_parser_)
      {
        this->bpej_parser_->post_bpej ();
        this->bpej ();
      }

      return true;
    }

    if (n == "bpejr2" && ns.empty ())
    {
      if (this->bpejr2_parser_)
      {
        this->bpejr2_parser_->post_bpejr2 ();
        this->bpejr2 ();
      }

      return true;
    }

    if (n == "mdp" && ns.empty ())
    {
      if (this->mdp_parser_)
      {
        this->mdp_parser_->post_mdpType ();
        this->mdp ();
      }

      return true;
    }

    if (n == "zs" && ns.empty ())
    {
      if (this->zs_parser_)
      {
        this->zs_parser_->post_zsType ();
        this->zs ();
      }

      return true;
    }

    if (n == "opu" && ns.empty ())
    {
      if (this->opu_parser_)
      {
        this->opu_parser_->post_opuType ();
        this->opu ();
      }

      return true;
    }

    if (n == "por" && ns.empty ())
    {
      if (this->por_parser_)
      {
        this->por_parser_->post_por1 ();
        this->por ();
      }

      return true;
    }

    if (n == "pbre" && ns.empty ())
    {
      if (this->pbre_parser_)
      {
        this->pbre_parser_->post_pbremCollectionType ();
        this->pbre ();
      }

      return true;
    }

    if (n == "spoz" && ns.empty ())
    {
      if (this->spoz_parser_)
      {
        this->spoz_parser_->post_spozCollectionType ();
        this->spoz ();
      }

      return true;
    }

    if (n == "pm" && ns.empty ())
    {
      if (this->pm_parser_)
      {
        this->pm_parser_->post_pmType ();
        this->pm ();
      }

      return true;
    }

    if (n == "mp" && ns.empty ())
    {
      if (this->mp_parser_)
      {
        this->mp_parser_->post_mpType ();
        this->mp ();
      }

      return true;
    }

    if (n == "meos" && ns.empty ())
    {
      if (this->meos_parser_)
      {
        this->meos_parser_->post_meosType ();
        this->meos ();
      }

      return true;
    }

    if (n == "meon" && ns.empty ())
    {
      if (this->meon_parser_)
      {
        this->meon_parser_->post_meonType ();
        this->meon ();
      }

      return true;
    }

    if (n == "hvpsz" && ns.empty ())
    {
      if (this->hvpsz_parser_)
      {
        this->hvpsz_parser_->post_hvpszType ();
        this->hvpsz ();
      }

      return true;
    }

    if (n == "zv" && ns.empty ())
    {
      if (this->zv_parser_)
      {
        this->zv_parser_->post_zv ();
        this->zv ();
      }

      return true;
    }

    return false;
  }

  // pa_pskel
  //

  void pa_pskel::
  gpar ()
  {
  }

  void pa_pskel::
  parid ()
  {
  }

  void pa_pskel::
  post_pa ()
  {
  }

  bool pa_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "gpar" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->gpar_parser_;

      if (this->gpar_parser_)
        this->gpar_parser_->pre ();

      return true;
    }

    return false;
  }

  bool pa_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "gpar" && ns.empty ())
    {
      if (this->gpar_parser_)
      {
        this->gpar_parser_->post_gparType ();
        this->gpar ();
      }

      return true;
    }

    return false;
  }

  bool pa_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
      return true;

    if (n == "parid" && ns.empty ())
    {
      if (this->parid_parser_)
      {
        this->parid_parser_->pre ();
        this->parid_parser_->_pre_impl ();
        this->parid_parser_->_characters (v);
        this->parid_parser_->_post_impl ();
        this->parid_parser_->post_parcelIdAttrType ();
        this->parid ();
      }

      return true;
    }

    return false;
  }

  // pa1_pskel
  //

  void pa1_pskel::
  gpar ()
  {
  }

  void pa1_pskel::
  ncn ()
  {
  }

  void pa1_pskel::
  parid ()
  {
  }

  void pa1_pskel::
  vymz ()
  {
  }

  void pa1_pskel::
  dpz ()
  {
  }

  void pa1_pskel::
  zvz ()
  {
  }

  void pa1_pskel::
  post_pa1 ()
  {
  }

  bool pa1_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "gpar" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->gpar_parser_;

      if (this->gpar_parser_)
        this->gpar_parser_->pre ();

      return true;
    }

    if (n == "ncn" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->ncn_parser_;

      if (this->ncn_parser_)
        this->ncn_parser_->pre ();

      return true;
    }

    return false;
  }

  bool pa1_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "gpar" && ns.empty ())
    {
      if (this->gpar_parser_)
      {
        this->gpar_parser_->post_gparType ();
        this->gpar ();
      }

      return true;
    }

    if (n == "ncn" && ns.empty ())
    {
      if (this->ncn_parser_)
      {
        this->ncn_parser_->post_newNumberCollectionType ();
        this->ncn ();
      }

      return true;
    }

    return false;
  }

  bool pa1_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
      return true;

    if (n == "parid" && ns.empty ())
    {
      if (this->parid_parser_)
      {
        this->parid_parser_->pre ();
        this->parid_parser_->_pre_impl ();
        this->parid_parser_->_characters (v);
        this->parid_parser_->_post_impl ();
        this->parid_parser_->post_parcelIdAttrType ();
        this->parid ();
      }

      return true;
    }

    if (n == "vymz" && ns.empty ())
    {
      if (this->vymz_parser_)
      {
        this->vymz_parser_->pre ();
        this->vymz_parser_->_pre_impl ();
        this->vymz_parser_->_characters (v);
        this->vymz_parser_->_post_impl ();
        this->vymz_parser_->post_areaAttrType ();
        this->vymz ();
      }

      return true;
    }

    if (n == "dpz" && ns.empty ())
    {
      if (this->dpz_parser_)
      {
        this->dpz_parser_->pre ();
        this->dpz_parser_->_pre_impl ();
        this->dpz_parser_->_characters (v);
        this->dpz_parser_->_post_impl ();
        this->dpz_parser_->post_kindOfAreaAttrType ();
        this->dpz ();
      }

      return true;
    }

    if (n == "zvz" && ns.empty ())
    {
      if (this->zvz_parser_)
      {
        this->zvz_parser_->pre ();
        this->zvz_parser_->_pre_impl ();
        this->zvz_parser_->_characters (v);
        this->zvz_parser_->_post_impl ();
        this->zvz_parser_->post_kindOfUseAttrType ();
        this->zvz ();
      }

      return true;
    }

    return false;
  }

  // dil_pskel
  //

  void dil_pskel::
  zo (long long)
  {
  }

  void dil_pskel::
  post_dil ()
  {
  }

  bool dil_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
      return true;

    if (n == "zo" && ns.empty ())
    {
      if (this->zo_parser_)
      {
        this->zo_parser_->pre ();
        this->zo_parser_->_pre_impl ();
        this->zo_parser_->_characters (v);
        this->zo_parser_->_post_impl ();
        this->zo (this->zo_parser_->post_integer ());
      }

      return true;
    }

    return false;
  }

  // vla_pskel
  //

  void vla_pskel::
  nvlas ()
  {
  }

  void vla_pskel::
  op_id ()
  {
  }

  void vla_pskel::
  cit ()
  {
  }

  void vla_pskel::
  jmen ()
  {
  }

  void vla_pskel::
  tpk (long long)
  {
  }

  void vla_pskel::
  rus ()
  {
  }

  void vla_pskel::
  post_vla ()
  {
  }

  bool vla_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "nvlas" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->nvlas_parser_;

      if (this->nvlas_parser_)
        this->nvlas_parser_->pre ();

      return true;
    }

    return false;
  }

  bool vla_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "nvlas" && ns.empty ())
    {
      if (this->nvlas_parser_)
      {
        this->nvlas_parser_->post_nvlaCollectionType ();
        this->nvlas ();
      }

      return true;
    }

    return false;
  }

  bool vla_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
      return true;

    if (n == "op_id" && ns.empty ())
    {
      if (this->op_id_parser_)
      {
        this->op_id_parser_->pre ();
        this->op_id_parser_->_pre_impl ();
        this->op_id_parser_->_characters (v);
        this->op_id_parser_->_post_impl ();
        this->op_id_parser_->post_opsubIdType ();
        this->op_id ();
      }

      return true;
    }

    if (n == "cit" && ns.empty ())
    {
      if (this->cit_parser_)
      {
        this->cit_parser_->pre ();
        this->cit_parser_->_pre_impl ();
        this->cit_parser_->_characters (v);
        this->cit_parser_->_post_impl ();
        this->cit_parser_->post_numeratorType ();
        this->cit ();
      }

      return true;
    }

    if (n == "jmen" && ns.empty ())
    {
      if (this->jmen_parser_)
      {
        this->jmen_parser_->pre ();
        this->jmen_parser_->_pre_impl ();
        this->jmen_parser_->_characters (v);
        this->jmen_parser_->_post_impl ();
        this->jmen_parser_->post_denominatorType ();
        this->jmen ();
      }

      return true;
    }

    if (n == "tpk" && ns.empty ())
    {
      if (this->tpk_parser_)
      {
        this->tpk_parser_->pre ();
        this->tpk_parser_->_pre_impl ();
        this->tpk_parser_->_characters (v);
        this->tpk_parser_->_post_impl ();
        this->tpk (this->tpk_parser_->post_integer ());
      }

      return true;
    }

    if (n == "rus" && ns.empty ())
    {
      if (this->rus_parser_)
      {
        this->rus_parser_->pre ();
        this->rus_parser_->_pre_impl ();
        this->rus_parser_->_characters (v);
        this->rus_parser_->_post_impl ();
        this->rus_parser_->post_rusAttrType ();
        this->rus ();
      }

      return true;
    }

    return false;
  }

  // lv_pskel
  //

  void lv_pskel::
  par ()
  {
  }

  void lv_pskel::
  ucas ()
  {
  }

  void lv_pskel::
  kk ()
  {
  }

  void lv_pskel::
  cis ()
  {
  }

  void lv_pskel::
  vymr ()
  {
  }

  void lv_pskel::
  vymnr ()
  {
  }

  void lv_pskel::
  cen ()
  {
  }

  void lv_pskel::
  vzd ()
  {
  }

  void lv_pskel::
  post_lv ()
  {
  }

  bool lv_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "par" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->par_parser_;

      if (this->par_parser_)
        this->par_parser_->pre ();

      return true;
    }

    if (n == "ucas" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->ucas_parser_;

      if (this->ucas_parser_)
        this->ucas_parser_->pre ();

      return true;
    }

    return false;
  }

  bool lv_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "par" && ns.empty ())
    {
      if (this->par_parser_)
      {
        this->par_parser_->post_par ();
        this->par ();
      }

      return true;
    }

    if (n == "ucas" && ns.empty ())
    {
      if (this->ucas_parser_)
      {
        this->ucas_parser_->post_ucaCollectionType ();
        this->ucas ();
      }

      return true;
    }

    return false;
  }

  bool lv_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
      return true;

    if (n == "kk" && ns.empty ())
    {
      if (this->kk_parser_)
      {
        this->kk_parser_->pre ();
        this->kk_parser_->_pre_impl ();
        this->kk_parser_->_characters (v);
        this->kk_parser_->_post_impl ();
        this->kk_parser_->post_cadasterCodeType ();
        this->kk ();
      }

      return true;
    }

    if (n == "cis" && ns.empty ())
    {
      if (this->cis_parser_)
      {
        this->cis_parser_->pre ();
        this->cis_parser_->_pre_impl ();
        this->cis_parser_->_characters (v);
        this->cis_parser_->_post_impl ();
        this->cis_parser_->post_lvNumberAttrType ();
        this->cis ();
      }

      return true;
    }

    if (n == "vymr" && ns.empty ())
    {
      if (this->vymr_parser_)
      {
        this->vymr_parser_->pre ();
        this->vymr_parser_->_pre_impl ();
        this->vymr_parser_->_characters (v);
        this->vymr_parser_->_post_impl ();
        this->vymr_parser_->post_areaAttrType ();
        this->vymr ();
      }

      return true;
    }

    if (n == "vymnr" && ns.empty ())
    {
      if (this->vymnr_parser_)
      {
        this->vymnr_parser_->pre ();
        this->vymnr_parser_->_pre_impl ();
        this->vymnr_parser_->_characters (v);
        this->vymnr_parser_->_post_impl ();
        this->vymnr_parser_->post_areaAttrType ();
        this->vymnr ();
      }

      return true;
    }

    if (n == "cen" && ns.empty ())
    {
      if (this->cen_parser_)
      {
        this->cen_parser_->pre ();
        this->cen_parser_->_pre_impl ();
        this->cen_parser_->_characters (v);
        this->cen_parser_->_post_impl ();
        this->cen_parser_->post_priceAttrType ();
        this->cen ();
      }

      return true;
    }

    if (n == "vzd" && ns.empty ())
    {
      if (this->vzd_parser_)
      {
        this->vzd_parser_->pre ();
        this->vzd_parser_->_pre_impl ();
        this->vzd_parser_->_characters (v);
        this->vzd_parser_->_post_impl ();
        this->vzd_parser_->post_distanceType ();
        this->vzd ();
      }

      return true;
    }

    return false;
  }

  // dil1_pskel
  //

  void dil1_pskel::
  typ ()
  {
  }

  void dil1_pskel::
  kod ()
  {
  }

  void dil1_pskel::
  vym ()
  {
  }

  void dil1_pskel::
  cen ()
  {
  }

  void dil1_pskel::
  poz (const ::std::string&)
  {
  }

  void dil1_pskel::
  post_dil1 ()
  {
  }

  bool dil1_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
      return true;

    if (n == "typ" && ns.empty ())
    {
      if (this->typ_parser_)
      {
        this->typ_parser_->pre ();
        this->typ_parser_->_pre_impl ();
        this->typ_parser_->_characters (v);
        this->typ_parser_->_post_impl ();
        this->typ_parser_->post_bpejType ();
        this->typ ();
      }

      return true;
    }

    if (n == "kod" && ns.empty ())
    {
      if (this->kod_parser_)
      {
        this->kod_parser_->pre ();
        this->kod_parser_->_pre_impl ();
        this->kod_parser_->_characters (v);
        this->kod_parser_->_post_impl ();
        this->kod_parser_->post_bpejCodeAttrType ();
        this->kod ();
      }

      return true;
    }

    if (n == "vym" && ns.empty ())
    {
      if (this->vym_parser_)
      {
        this->vym_parser_->pre ();
        this->vym_parser_->_pre_impl ();
        this->vym_parser_->_characters (v);
        this->vym_parser_->_post_impl ();
        this->vym_parser_->post_areaAttrType ();
        this->vym ();
      }

      return true;
    }

    if (n == "cen" && ns.empty ())
    {
      if (this->cen_parser_)
      {
        this->cen_parser_->pre ();
        this->cen_parser_->_pre_impl ();
        this->cen_parser_->_characters (v);
        this->cen_parser_->_post_impl ();
        this->cen_parser_->post_priceAttrType ();
        this->cen ();
      }

      return true;
    }

    if (n == "poz" && ns.empty ())
    {
      if (this->poz_parser_)
      {
        this->poz_parser_->pre ();
        this->poz_parser_->_pre_impl ();
        this->poz_parser_->_characters (v);
        this->poz_parser_->_post_impl ();
        this->poz (this->poz_parser_->post_string ());
      }

      return true;
    }

    return false;
  }

  // dil2_pskel
  //

  void dil2_pskel::
  typ ()
  {
  }

  void dil2_pskel::
  kod ()
  {
  }

  void dil2_pskel::
  vym ()
  {
  }

  void dil2_pskel::
  cen ()
  {
  }

  void dil2_pskel::
  poz (const ::std::string&)
  {
  }

  void dil2_pskel::
  dp ()
  {
  }

  void dil2_pskel::
  zv ()
  {
  }

  void dil2_pskel::
  post_dil2 ()
  {
  }

  bool dil2_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
      return true;

    if (n == "typ" && ns.empty ())
    {
      if (this->typ_parser_)
      {
        this->typ_parser_->pre ();
        this->typ_parser_->_pre_impl ();
        this->typ_parser_->_characters (v);
        this->typ_parser_->_post_impl ();
        this->typ_parser_->post_bpejType ();
        this->typ ();
      }

      return true;
    }

    if (n == "kod" && ns.empty ())
    {
      if (this->kod_parser_)
      {
        this->kod_parser_->pre ();
        this->kod_parser_->_pre_impl ();
        this->kod_parser_->_characters (v);
        this->kod_parser_->_post_impl ();
        this->kod_parser_->post_bpejCodeAttrType ();
        this->kod ();
      }

      return true;
    }

    if (n == "vym" && ns.empty ())
    {
      if (this->vym_parser_)
      {
        this->vym_parser_->pre ();
        this->vym_parser_->_pre_impl ();
        this->vym_parser_->_characters (v);
        this->vym_parser_->_post_impl ();
        this->vym_parser_->post_areaAttrType ();
        this->vym ();
      }

      return true;
    }

    if (n == "cen" && ns.empty ())
    {
      if (this->cen_parser_)
      {
        this->cen_parser_->pre ();
        this->cen_parser_->_pre_impl ();
        this->cen_parser_->_characters (v);
        this->cen_parser_->_post_impl ();
        this->cen_parser_->post_priceAttrType ();
        this->cen ();
      }

      return true;
    }

    if (n == "poz" && ns.empty ())
    {
      if (this->poz_parser_)
      {
        this->poz_parser_->pre ();
        this->poz_parser_->_pre_impl ();
        this->poz_parser_->_characters (v);
        this->poz_parser_->_post_impl ();
        this->poz (this->poz_parser_->post_string ());
      }

      return true;
    }

    if (n == "dp" && ns.empty ())
    {
      if (this->dp_parser_)
      {
        this->dp_parser_->pre ();
        this->dp_parser_->_pre_impl ();
        this->dp_parser_->_characters (v);
        this->dp_parser_->_post_impl ();
        this->dp_parser_->post_kindOfAreaAttrType ();
        this->dp ();
      }

      return true;
    }

    if (n == "zv" && ns.empty ())
    {
      if (this->zv_parser_)
      {
        this->zv_parser_->pre ();
        this->zv_parser_->_pre_impl ();
        this->zv_parser_->_characters (v);
        this->zv_parser_->_post_impl ();
        this->zv_parser_->post_kindOfUseAttrType ();
        this->zv ();
      }

      return true;
    }

    return false;
  }

  // lv1_pskel
  //

  void lv1_pskel::
  par ()
  {
  }

  void lv1_pskel::
  vlas ()
  {
  }

  void lv1_pskel::
  ucas ()
  {
  }

  void lv1_pskel::
  cis ()
  {
  }

  void lv1_pskel::
  kk ()
  {
  }

  void lv1_pskel::
  post_lv1 ()
  {
  }

  bool lv1_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "par" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->par_parser_;

      if (this->par_parser_)
        this->par_parser_->pre ();

      return true;
    }

    if (n == "vlas" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->vlas_parser_;

      if (this->vlas_parser_)
        this->vlas_parser_->pre ();

      return true;
    }

    if (n == "ucas" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->ucas_parser_;

      if (this->ucas_parser_)
        this->ucas_parser_->pre ();

      return true;
    }

    return false;
  }

  bool lv1_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "par" && ns.empty ())
    {
      if (this->par_parser_)
      {
        this->par_parser_->post_par1 ();
        this->par ();
      }

      return true;
    }

    if (n == "vlas" && ns.empty ())
    {
      if (this->vlas_parser_)
      {
        this->vlas_parser_->post_vlaCollectionType ();
        this->vlas ();
      }

      return true;
    }

    if (n == "ucas" && ns.empty ())
    {
      if (this->ucas_parser_)
      {
        this->ucas_parser_->post_ucaCollectionType ();
        this->ucas ();
      }

      return true;
    }

    return false;
  }

  bool lv1_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
      return true;

    if (n == "cis" && ns.empty ())
    {
      if (this->cis_parser_)
      {
        this->cis_parser_->pre ();
        this->cis_parser_->_pre_impl ();
        this->cis_parser_->_characters (v);
        this->cis_parser_->_post_impl ();
        this->cis_parser_->post_lvNumberAttrType ();
        this->cis ();
      }

      return true;
    }

    if (n == "kk" && ns.empty ())
    {
      if (this->kk_parser_)
      {
        this->kk_parser_->pre ();
        this->kk_parser_->_pre_impl ();
        this->kk_parser_->_characters (v);
        this->kk_parser_->_post_impl ();
        this->kk_parser_->post_cadasterCodeType ();
        this->kk ();
      }

      return true;
    }

    return false;
  }

  // pl_pskel
  //

  void pl_pskel::
  area ()
  {
  }

  void pl_pskel::
  id ()
  {
  }

  void pl_pskel::
  dp ()
  {
  }

  void pl_pskel::
  zv ()
  {
  }

  void pl_pskel::
  post_pl ()
  {
  }

  bool pl_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "area" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->area_parser_;

      if (this->area_parser_)
        this->area_parser_->pre ();

      return true;
    }

    return false;
  }

  bool pl_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "area" && ns.empty ())
    {
      if (this->area_parser_)
      {
        this->area_parser_->post_areaType ();
        this->area ();
      }

      return true;
    }

    return false;
  }

  bool pl_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
      return true;

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();
        this->id_parser_->_pre_impl ();
        this->id_parser_->_characters (v);
        this->id_parser_->_post_impl ();
        this->id_parser_->post_basicIdAttrType ();
        this->id ();
      }

      return true;
    }

    if (n == "dp" && ns.empty ())
    {
      if (this->dp_parser_)
      {
        this->dp_parser_->pre ();
        this->dp_parser_->_pre_impl ();
        this->dp_parser_->_characters (v);
        this->dp_parser_->_post_impl ();
        this->dp_parser_->post_kindOfAreaAttrType ();
        this->dp ();
      }

      return true;
    }

    if (n == "zv" && ns.empty ())
    {
      if (this->zv_parser_)
      {
        this->zv_parser_->pre ();
        this->zv_parser_->_pre_impl ();
        this->zv_parser_->_characters (v);
        this->zv_parser_->_post_impl ();
        this->zv_parser_->post_kindOfUseAttrType ();
        this->zv ();
      }

      return true;
    }

    return false;
  }

  // plins_pskel
  //

  void plins_pskel::
  plin ()
  {
  }

  void plins_pskel::
  post_plins ()
  {
  }

  bool plins_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "plin" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->plin_parser_;

      if (this->plin_parser_)
        this->plin_parser_->pre ();

      return true;
    }

    return false;
  }

  bool plins_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "plin" && ns.empty ())
    {
      if (this->plin_parser_)
      {
        this->plin_parser_->post_plin ();
        this->plin ();
      }

      return true;
    }

    return false;
  }

  // pznas_pskel
  //

  void pznas_pskel::
  pzna ()
  {
  }

  void pznas_pskel::
  post_pznas ()
  {
  }

  bool pznas_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "pzna" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->pzna_parser_;

      if (this->pzna_parser_)
        this->pzna_parser_->pre ();

      return true;
    }

    return false;
  }

  bool pznas_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "pzna" && ns.empty ())
    {
      if (this->pzna_parser_)
      {
        this->pzna_parser_->post_pzna ();
        this->pzna ();
      }

      return true;
    }

    return false;
  }

  // ptexts_pskel
  //

  void ptexts_pskel::
  ptext ()
  {
  }

  void ptexts_pskel::
  post_ptexts ()
  {
  }

  bool ptexts_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "ptext" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->ptext_parser_;

      if (this->ptext_parser_)
        this->ptext_parser_->pre ();

      return true;
    }

    return false;
  }

  bool ptexts_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "ptext" && ns.empty ())
    {
      if (this->ptext_parser_)
      {
        this->ptext_parser_->post_ptext ();
        this->ptext ();
      }

      return true;
    }

    return false;
  }

  // psour_pskel
  //

  void psour_pskel::
  psou ()
  {
  }

  void psour_pskel::
  post_psour ()
  {
  }

  bool psour_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "psou" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->psou_parser_;

      if (this->psou_parser_)
        this->psou_parser_->pre ();

      return true;
    }

    return false;
  }

  bool psour_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "psou" && ns.empty ())
    {
      if (this->psou_parser_)
      {
        this->psou_parser_->post_psouType ();
        this->psou ();
      }

      return true;
    }

    return false;
  }

  // pmlins_pskel
  //

  void pmlins_pskel::
  pmlin ()
  {
  }

  void pmlins_pskel::
  post_pmlins ()
  {
  }

  bool pmlins_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "pmlin" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->pmlin_parser_;

      if (this->pmlin_parser_)
        this->pmlin_parser_->pre ();

      return true;
    }

    return false;
  }

  bool pmlins_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "pmlin" && ns.empty ())
    {
      if (this->pmlin_parser_)
      {
        this->pmlin_parser_->post_plin ();
        this->pmlin ();
      }

      return true;
    }

    return false;
  }

  // pmznas_pskel
  //

  void pmznas_pskel::
  pmzna ()
  {
  }

  void pmznas_pskel::
  post_pmznas ()
  {
  }

  bool pmznas_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "pmzna" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->pmzna_parser_;

      if (this->pmzna_parser_)
        this->pmzna_parser_->pre ();

      return true;
    }

    return false;
  }

  bool pmznas_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "pmzna" && ns.empty ())
    {
      if (this->pmzna_parser_)
      {
        this->pmzna_parser_->post_pzna ();
        this->pmzna ();
      }

      return true;
    }

    return false;
  }

  // pmtexts_pskel
  //

  void pmtexts_pskel::
  pmtext ()
  {
  }

  void pmtexts_pskel::
  post_pmtexts ()
  {
  }

  bool pmtexts_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "pmtext" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->pmtext_parser_;

      if (this->pmtext_parser_)
        this->pmtext_parser_->pre ();

      return true;
    }

    return false;
  }

  bool pmtexts_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "pmtext" && ns.empty ())
    {
      if (this->pmtext_parser_)
      {
        this->pmtext_parser_->post_ptext ();
        this->pmtext ();
      }

      return true;
    }

    return false;
  }

  // pmareas_pskel
  //

  void pmareas_pskel::
  pmarea ()
  {
  }

  void pmareas_pskel::
  post_pmareas ()
  {
  }

  bool pmareas_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "pmarea" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->pmarea_parser_;

      if (this->pmarea_parser_)
        this->pmarea_parser_->pre ();

      return true;
    }

    return false;
  }

  bool pmareas_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "pmarea" && ns.empty ())
    {
      if (this->pmarea_parser_)
      {
        this->pmarea_parser_->post_parea ();
        this->pmarea ();
      }

      return true;
    }

    return false;
  }

  // mplins_pskel
  //

  void mplins_pskel::
  mplin ()
  {
  }

  void mplins_pskel::
  post_mplins ()
  {
  }

  bool mplins_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "mplin" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->mplin_parser_;

      if (this->mplin_parser_)
        this->mplin_parser_->pre ();

      return true;
    }

    return false;
  }

  bool mplins_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "mplin" && ns.empty ())
    {
      if (this->mplin_parser_)
      {
        this->mplin_parser_->post_plin ();
        this->mplin ();
      }

      return true;
    }

    return false;
  }

  // mpznas_pskel
  //

  void mpznas_pskel::
  mpzna ()
  {
  }

  void mpznas_pskel::
  post_mpznas ()
  {
  }

  bool mpznas_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "mpzna" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->mpzna_parser_;

      if (this->mpzna_parser_)
        this->mpzna_parser_->pre ();

      return true;
    }

    return false;
  }

  bool mpznas_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "mpzna" && ns.empty ())
    {
      if (this->mpzna_parser_)
      {
        this->mpzna_parser_->post_pzna ();
        this->mpzna ();
      }

      return true;
    }

    return false;
  }

  // mptexts_pskel
  //

  void mptexts_pskel::
  mptext ()
  {
  }

  void mptexts_pskel::
  post_mptexts ()
  {
  }

  bool mptexts_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "mptext" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->mptext_parser_;

      if (this->mptext_parser_)
        this->mptext_parser_->pre ();

      return true;
    }

    return false;
  }

  bool mptexts_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "mptext" && ns.empty ())
    {
      if (this->mptext_parser_)
      {
        this->mptext_parser_->post_ptext ();
        this->mptext ();
      }

      return true;
    }

    return false;
  }

  // mpareas_pskel
  //

  void mpareas_pskel::
  mparea ()
  {
  }

  void mpareas_pskel::
  post_mpareas ()
  {
  }

  bool mpareas_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "mparea" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->mparea_parser_;

      if (this->mparea_parser_)
        this->mparea_parser_->pre ();

      return true;
    }

    return false;
  }

  bool mpareas_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "mparea" && ns.empty ())
    {
      if (this->mparea_parser_)
      {
        this->mparea_parser_->post_parea ();
        this->mparea ();
      }

      return true;
    }

    return false;
  }

  // meoslins_pskel
  //

  void meoslins_pskel::
  meoslin ()
  {
  }

  void meoslins_pskel::
  post_meoslins ()
  {
  }

  bool meoslins_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "meoslin" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->meoslin_parser_;

      if (this->meoslin_parser_)
        this->meoslin_parser_->pre ();

      return true;
    }

    return false;
  }

  bool meoslins_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "meoslin" && ns.empty ())
    {
      if (this->meoslin_parser_)
      {
        this->meoslin_parser_->post_plin ();
        this->meoslin ();
      }

      return true;
    }

    return false;
  }

  // meosznas_pskel
  //

  void meosznas_pskel::
  meoszna ()
  {
  }

  void meosznas_pskel::
  post_meosznas ()
  {
  }

  bool meosznas_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "meoszna" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->meoszna_parser_;

      if (this->meoszna_parser_)
        this->meoszna_parser_->pre ();

      return true;
    }

    return false;
  }

  bool meosznas_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "meoszna" && ns.empty ())
    {
      if (this->meoszna_parser_)
      {
        this->meoszna_parser_->post_pzna ();
        this->meoszna ();
      }

      return true;
    }

    return false;
  }

  // meostexts_pskel
  //

  void meostexts_pskel::
  meostext ()
  {
  }

  void meostexts_pskel::
  post_meostexts ()
  {
  }

  bool meostexts_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "meostext" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->meostext_parser_;

      if (this->meostext_parser_)
        this->meostext_parser_->pre ();

      return true;
    }

    return false;
  }

  bool meostexts_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "meostext" && ns.empty ())
    {
      if (this->meostext_parser_)
      {
        this->meostext_parser_->post_ptext ();
        this->meostext ();
      }

      return true;
    }

    return false;
  }

  // meosareas_pskel
  //

  void meosareas_pskel::
  meosarea ()
  {
  }

  void meosareas_pskel::
  post_meosareas ()
  {
  }

  bool meosareas_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "meosarea" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->meosarea_parser_;

      if (this->meosarea_parser_)
        this->meosarea_parser_->pre ();

      return true;
    }

    return false;
  }

  bool meosareas_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "meosarea" && ns.empty ())
    {
      if (this->meosarea_parser_)
      {
        this->meosarea_parser_->post_parea ();
        this->meosarea ();
      }

      return true;
    }

    return false;
  }

  // meonlins_pskel
  //

  void meonlins_pskel::
  meonlin ()
  {
  }

  void meonlins_pskel::
  post_meonlins ()
  {
  }

  bool meonlins_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "meonlin" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->meonlin_parser_;

      if (this->meonlin_parser_)
        this->meonlin_parser_->pre ();

      return true;
    }

    return false;
  }

  bool meonlins_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "meonlin" && ns.empty ())
    {
      if (this->meonlin_parser_)
      {
        this->meonlin_parser_->post_plin ();
        this->meonlin ();
      }

      return true;
    }

    return false;
  }

  // meonznas_pskel
  //

  void meonznas_pskel::
  meonzna ()
  {
  }

  void meonznas_pskel::
  post_meonznas ()
  {
  }

  bool meonznas_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "meonzna" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->meonzna_parser_;

      if (this->meonzna_parser_)
        this->meonzna_parser_->pre ();

      return true;
    }

    return false;
  }

  bool meonznas_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "meonzna" && ns.empty ())
    {
      if (this->meonzna_parser_)
      {
        this->meonzna_parser_->post_pzna ();
        this->meonzna ();
      }

      return true;
    }

    return false;
  }

  // meontexts_pskel
  //

  void meontexts_pskel::
  meontext ()
  {
  }

  void meontexts_pskel::
  post_meontexts ()
  {
  }

  bool meontexts_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "meontext" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->meontext_parser_;

      if (this->meontext_parser_)
        this->meontext_parser_->pre ();

      return true;
    }

    return false;
  }

  bool meontexts_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "meontext" && ns.empty ())
    {
      if (this->meontext_parser_)
      {
        this->meontext_parser_->post_ptext ();
        this->meontext ();
      }

      return true;
    }

    return false;
  }

  // meonareas_pskel
  //

  void meonareas_pskel::
  meonarea ()
  {
  }

  void meonareas_pskel::
  post_meonareas ()
  {
  }

  bool meonareas_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "meonarea" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->meonarea_parser_;

      if (this->meonarea_parser_)
        this->meonarea_parser_->pre ();

      return true;
    }

    return false;
  }

  bool meonareas_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "meonarea" && ns.empty ())
    {
      if (this->meonarea_parser_)
      {
        this->meonarea_parser_->post_parea ();
        this->meonarea ();
      }

      return true;
    }

    return false;
  }

  // hvpszlins_pskel
  //

  void hvpszlins_pskel::
  hvpszlin ()
  {
  }

  void hvpszlins_pskel::
  post_hvpszlins ()
  {
  }

  bool hvpszlins_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "hvpszlin" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->hvpszlin_parser_;

      if (this->hvpszlin_parser_)
        this->hvpszlin_parser_->pre ();

      return true;
    }

    return false;
  }

  bool hvpszlins_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "hvpszlin" && ns.empty ())
    {
      if (this->hvpszlin_parser_)
      {
        this->hvpszlin_parser_->post_plin ();
        this->hvpszlin ();
      }

      return true;
    }

    return false;
  }

  // hvpszznas_pskel
  //

  void hvpszznas_pskel::
  hvpszzna ()
  {
  }

  void hvpszznas_pskel::
  post_hvpszznas ()
  {
  }

  bool hvpszznas_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "hvpszzna" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->hvpszzna_parser_;

      if (this->hvpszzna_parser_)
        this->hvpszzna_parser_->pre ();

      return true;
    }

    return false;
  }

  bool hvpszznas_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "hvpszzna" && ns.empty ())
    {
      if (this->hvpszzna_parser_)
      {
        this->hvpszzna_parser_->post_pzna ();
        this->hvpszzna ();
      }

      return true;
    }

    return false;
  }

  // hvpsztexts_pskel
  //

  void hvpsztexts_pskel::
  hvpsztext ()
  {
  }

  void hvpsztexts_pskel::
  post_hvpsztexts ()
  {
  }

  bool hvpsztexts_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "hvpsztext" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->hvpsztext_parser_;

      if (this->hvpsztext_parser_)
        this->hvpsztext_parser_->pre ();

      return true;
    }

    return false;
  }

  bool hvpsztexts_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "hvpsztext" && ns.empty ())
    {
      if (this->hvpsztext_parser_)
      {
        this->hvpsztext_parser_->post_ptext ();
        this->hvpsztext ();
      }

      return true;
    }

    return false;
  }

  // hvpszareas_pskel
  //

  void hvpszareas_pskel::
  hvpszarea ()
  {
  }

  void hvpszareas_pskel::
  post_hvpszareas ()
  {
  }

  bool hvpszareas_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "hvpszarea" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->hvpszarea_parser_;

      if (this->hvpszarea_parser_)
        this->hvpszarea_parser_->pre ();

      return true;
    }

    return false;
  }

  bool hvpszareas_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "hvpszarea" && ns.empty ())
    {
      if (this->hvpszarea_parser_)
      {
        this->hvpszarea_parser_->post_parea ();
        this->hvpszarea ();
      }

      return true;
    }

    return false;
  }

  // zvbod_pskel
  //

  void zvbod_pskel::
  c ()
  {
  }

  void zvbod_pskel::
  cb (long long)
  {
  }

  void zvbod_pskel::
  post_zvbod ()
  {
  }

  bool zvbod_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "c" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->c_parser_;

      if (this->c_parser_)
        this->c_parser_->pre ();

      return true;
    }

    return false;
  }

  bool zvbod_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "c" && ns.empty ())
    {
      if (this->c_parser_)
      {
        this->c_parser_->post_coordinateType ();
        this->c ();
      }

      return true;
    }

    return false;
  }

  bool zvbod_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
      return true;

    if (n == "cb" && ns.empty ())
    {
      if (this->cb_parser_)
      {
        this->cb_parser_->pre ();
        this->cb_parser_->_pre_impl ();
        this->cb_parser_->_characters (v);
        this->cb_parser_->_post_impl ();
        this->cb (this->cb_parser_->post_integer ());
      }

      return true;
    }

    return false;
  }

  // zvlin_pskel
  //

  void zvlin_pskel::
  lin ()
  {
  }

  void zvlin_pskel::
  post_zvlin ()
  {
  }

  bool zvlin_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "lin" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->lin_parser_;

      if (this->lin_parser_)
        this->lin_parser_->pre ();

      return true;
    }

    return false;
  }

  bool zvlin_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "lin" && ns.empty ())
    {
      if (this->lin_parser_)
      {
        this->lin_parser_->post_linearType ();
        this->lin ();
      }

      return true;
    }

    return false;
  }

  // zvarea_pskel
  //

  void zvarea_pskel::
  reg ()
  {
  }

  void zvarea_pskel::
  post_zvarea ()
  {
  }

  bool zvarea_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "reg" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->reg_parser_;

      if (this->reg_parser_)
        this->reg_parser_->pre ();

      return true;
    }

    return false;
  }

  bool zvarea_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "reg" && ns.empty ())
    {
      if (this->reg_parser_)
      {
        this->reg_parser_->post_regionType ();
        this->reg ();
      }

      return true;
    }

    return false;
  }

  // pl1_pskel
  //

  void pl1_pskel::
  reg ()
  {
  }

  void pl1_pskel::
  sour ()
  {
  }

  void pl1_pskel::
  id ()
  {
  }

  void pl1_pskel::
  res ()
  {
  }

  void pl1_pskel::
  poz ()
  {
  }

  void pl1_pskel::
  post_pl1 ()
  {
  }

  bool pl1_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "reg" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->reg_parser_;

      if (this->reg_parser_)
        this->reg_parser_->pre ();

      return true;
    }

    if (n == "sour" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->sour_parser_;

      if (this->sour_parser_)
        this->sour_parser_->pre ();

      return true;
    }

    return false;
  }

  bool pl1_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "reg" && ns.empty ())
    {
      if (this->reg_parser_)
      {
        this->reg_parser_->post_regionType ();
        this->reg ();
      }

      return true;
    }

    if (n == "sour" && ns.empty ())
    {
      if (this->sour_parser_)
      {
        this->sour_parser_->post_sour ();
        this->sour ();
      }

      return true;
    }

    return false;
  }

  bool pl1_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
      return true;

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();
        this->id_parser_->_pre_impl ();
        this->id_parser_->_characters (v);
        this->id_parser_->_post_impl ();
        this->id_parser_->post_basicIdAttrType ();
        this->id ();
      }

      return true;
    }

    if (n == "res" && ns.empty ())
    {
      if (this->res_parser_)
      {
        this->res_parser_->pre ();
        this->res_parser_->_pre_impl ();
        this->res_parser_->_characters (v);
        this->res_parser_->_post_impl ();
        this->res_parser_->post_resAttrType ();
        this->res ();
      }

      return true;
    }

    if (n == "poz" && ns.empty ())
    {
      if (this->poz_parser_)
      {
        this->poz_parser_->pre ();
        this->poz_parser_->_pre_impl ();
        this->poz_parser_->_characters (v);
        this->poz_parser_->_post_impl ();
        this->poz_parser_->post_noteAttrType ();
        this->poz ();
      }

      return true;
    }

    return false;
  }

  // pl2_pskel
  //

  void pl2_pskel::
  area ()
  {
  }

  void pl2_pskel::
  id ()
  {
  }

  void pl2_pskel::
  typ ()
  {
  }

  void pl2_pskel::
  popis ()
  {
  }

  void pl2_pskel::
  post_pl2 ()
  {
  }

  bool pl2_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "area" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->area_parser_;

      if (this->area_parser_)
        this->area_parser_->pre ();

      return true;
    }

    return false;
  }

  bool pl2_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "area" && ns.empty ())
    {
      if (this->area_parser_)
      {
        this->area_parser_->post_areaType ();
        this->area ();
      }

      return true;
    }

    return false;
  }

  bool pl2_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
      return true;

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();
        this->id_parser_->_pre_impl ();
        this->id_parser_->_characters (v);
        this->id_parser_->_post_impl ();
        this->id_parser_->post_basicIdAttrType ();
        this->id ();
      }

      return true;
    }

    if (n == "typ" && ns.empty ())
    {
      if (this->typ_parser_)
      {
        this->typ_parser_->pre ();
        this->typ_parser_->_pre_impl ();
        this->typ_parser_->_characters (v);
        this->typ_parser_->_post_impl ();
        this->typ_parser_->post_typPravAttrType ();
        this->typ ();
      }

      return true;
    }

    if (n == "popis" && ns.empty ())
    {
      if (this->popis_parser_)
      {
        this->popis_parser_->pre ();
        this->popis_parser_->_pre_impl ();
        this->popis_parser_->_characters (v);
        this->popis_parser_->_post_impl ();
        this->popis_parser_->post_notEmptyStringType ();
        this->popis ();
      }

      return true;
    }

    return false;
  }

  // pl3_pskel
  //

  void pl3_pskel::
  area ()
  {
  }

  void pl3_pskel::
  id ()
  {
  }

  void pl3_pskel::
  op (long long)
  {
  }

  void pl3_pskel::
  psz ()
  {
  }

  void pl3_pskel::
  post_pl3 ()
  {
  }

  bool pl3_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "area" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->area_parser_;

      if (this->area_parser_)
        this->area_parser_->pre ();

      return true;
    }

    return false;
  }

  bool pl3_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "area" && ns.empty ())
    {
      if (this->area_parser_)
      {
        this->area_parser_->post_areaType ();
        this->area ();
      }

      return true;
    }

    return false;
  }

  bool pl3_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
      return true;

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();
        this->id_parser_->_pre_impl ();
        this->id_parser_->_characters (v);
        this->id_parser_->_post_impl ();
        this->id_parser_->post_basicIdAttrType ();
        this->id ();
      }

      return true;
    }

    if (n == "op" && ns.empty ())
    {
      if (this->op_parser_)
      {
        this->op_parser_->pre ();
        this->op_parser_->_pre_impl ();
        this->op_parser_->_characters (v);
        this->op_parser_->_post_impl ();
        this->op (this->op_parser_->post_integer ());
      }

      return true;
    }

    if (n == "psz" && ns.empty ())
    {
      if (this->psz_parser_)
      {
        this->psz_parser_->pre ();
        this->psz_parser_->_pre_impl ();
        this->psz_parser_->_characters (v);
        this->psz_parser_->_post_impl ();
        this->psz_parser_->post_notEmptyStringType ();
        this->psz ();
      }

      return true;
    }

    return false;
  }

  // bpej_pskel
  //

  void bpej_pskel::
  pl ()
  {
  }

  void bpej_pskel::
  post_bpej ()
  {
  }

  bool bpej_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "pl" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->pl_parser_;

      if (this->pl_parser_)
        this->pl_parser_->pre ();

      return true;
    }

    return false;
  }

  bool bpej_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "pl" && ns.empty ())
    {
      if (this->pl_parser_)
      {
        this->pl_parser_->post_pl4 ();
        this->pl ();
      }

      return true;
    }

    return false;
  }

  // bpejr2_pskel
  //

  void bpejr2_pskel::
  pl ()
  {
  }

  void bpejr2_pskel::
  post_bpejr2 ()
  {
  }

  bool bpejr2_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "pl" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->pl_parser_;

      if (this->pl_parser_)
        this->pl_parser_->pre ();

      return true;
    }

    return false;
  }

  bool bpejr2_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "pl" && ns.empty ())
    {
      if (this->pl_parser_)
      {
        this->pl_parser_->post_pl5 ();
        this->pl ();
      }

      return true;
    }

    return false;
  }

  // por1_pskel
  //

  void por1_pskel::
  porost ()
  {
  }

  void por1_pskel::
  post_por1 ()
  {
  }

  bool por1_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "porost" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->porost_parser_;

      if (this->porost_parser_)
        this->porost_parser_->pre ();

      return true;
    }

    return false;
  }

  bool por1_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "porost" && ns.empty ())
    {
      if (this->porost_parser_)
      {
        this->porost_parser_->post_porostType ();
        this->porost ();
      }

      return true;
    }

    return false;
  }

  // zv_pskel
  //

  void zv_pskel::
  zvbods ()
  {
  }

  void zv_pskel::
  zvlins ()
  {
  }

  void zv_pskel::
  zvareas ()
  {
  }

  void zv_pskel::
  post_zv ()
  {
  }

  bool zv_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "zvbods" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->zvbods_parser_;

      if (this->zvbods_parser_)
        this->zvbods_parser_->pre ();

      return true;
    }

    if (n == "zvlins" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->zvlins_parser_;

      if (this->zvlins_parser_)
        this->zvlins_parser_->pre ();

      return true;
    }

    if (n == "zvareas" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->zvareas_parser_;

      if (this->zvareas_parser_)
        this->zvareas_parser_->pre ();

      return true;
    }

    return false;
  }

  bool zv_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "zvbods" && ns.empty ())
    {
      if (this->zvbods_parser_)
      {
        this->zvbods_parser_->post_zvbodsType ();
        this->zvbods ();
      }

      return true;
    }

    if (n == "zvlins" && ns.empty ())
    {
      if (this->zvlins_parser_)
      {
        this->zvlins_parser_->post_zvlinsType ();
        this->zvlins ();
      }

      return true;
    }

    if (n == "zvareas" && ns.empty ())
    {
      if (this->zvareas_parser_)
      {
        this->zvareas_parser_->post_zvareasType ();
        this->zvareas ();
      }

      return true;
    }

    return false;
  }

  // par_pskel
  //

  void par_pskel::
  pa ()
  {
  }

  void par_pskel::
  post_par ()
  {
  }

  bool par_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "pa" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->pa_parser_;

      if (this->pa_parser_)
        this->pa_parser_->pre ();

      return true;
    }

    return false;
  }

  bool par_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "pa" && ns.empty ())
    {
      if (this->pa_parser_)
      {
        this->pa_parser_->post_pa2 ();
        this->pa ();
      }

      return true;
    }

    return false;
  }

  // par1_pskel
  //

  void par1_pskel::
  pa ()
  {
  }

  void par1_pskel::
  post_par1 ()
  {
  }

  bool par1_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "pa" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->pa_parser_;

      if (this->pa_parser_)
        this->pa_parser_->pre ();

      return true;
    }

    return false;
  }

  bool par1_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "pa" && ns.empty ())
    {
      if (this->pa_parser_)
      {
        this->pa_parser_->post_pa3 ();
        this->pa ();
      }

      return true;
    }

    return false;
  }

  // sour_pskel
  //

  void sour_pskel::
  sou ()
  {
  }

  void sour_pskel::
  post_sour ()
  {
  }

  bool sour_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "sou" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->sou_parser_;

      if (this->sou_parser_)
        this->sou_parser_->pre ();

      return true;
    }

    return false;
  }

  bool sour_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "sou" && ns.empty ())
    {
      if (this->sou_parser_)
      {
        this->sou_parser_->post_souType ();
        this->sou ();
      }

      return true;
    }

    return false;
  }

  // pl4_pskel
  //

  void pl4_pskel::
  area ()
  {
  }

  void pl4_pskel::
  id ()
  {
  }

  void pl4_pskel::
  kod ()
  {
  }

  void pl4_pskel::
  cena ()
  {
  }

  void pl4_pskel::
  post_pl4 ()
  {
  }

  bool pl4_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "area" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->area_parser_;

      if (this->area_parser_)
        this->area_parser_->pre ();

      return true;
    }

    return false;
  }

  bool pl4_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "area" && ns.empty ())
    {
      if (this->area_parser_)
      {
        this->area_parser_->post_areaType ();
        this->area ();
      }

      return true;
    }

    return false;
  }

  bool pl4_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
      return true;

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();
        this->id_parser_->_pre_impl ();
        this->id_parser_->_characters (v);
        this->id_parser_->_post_impl ();
        this->id_parser_->post_basicIdAttrType ();
        this->id ();
      }

      return true;
    }

    if (n == "kod" && ns.empty ())
    {
      if (this->kod_parser_)
      {
        this->kod_parser_->pre ();
        this->kod_parser_->_pre_impl ();
        this->kod_parser_->_characters (v);
        this->kod_parser_->_post_impl ();
        this->kod_parser_->post_bpejCodeAttrType ();
        this->kod ();
      }

      return true;
    }

    if (n == "cena" && ns.empty ())
    {
      if (this->cena_parser_)
      {
        this->cena_parser_->pre ();
        this->cena_parser_->_pre_impl ();
        this->cena_parser_->_characters (v);
        this->cena_parser_->_post_impl ();
        this->cena_parser_->post_priceAttrType ();
        this->cena ();
      }

      return true;
    }

    return false;
  }

  // pl5_pskel
  //

  void pl5_pskel::
  area ()
  {
  }

  void pl5_pskel::
  id ()
  {
  }

  void pl5_pskel::
  kod ()
  {
  }

  void pl5_pskel::
  post_pl5 ()
  {
  }

  bool pl5_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "area" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->area_parser_;

      if (this->area_parser_)
        this->area_parser_->pre ();

      return true;
    }

    return false;
  }

  bool pl5_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "area" && ns.empty ())
    {
      if (this->area_parser_)
      {
        this->area_parser_->post_areaType ();
        this->area ();
      }

      return true;
    }

    return false;
  }

  bool pl5_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
      return true;

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();
        this->id_parser_->_pre_impl ();
        this->id_parser_->_characters (v);
        this->id_parser_->_post_impl ();
        this->id_parser_->post_basicIdAttrType ();
        this->id ();
      }

      return true;
    }

    if (n == "kod" && ns.empty ())
    {
      if (this->kod_parser_)
      {
        this->kod_parser_->pre ();
        this->kod_parser_->_pre_impl ();
        this->kod_parser_->_characters (v);
        this->kod_parser_->_post_impl ();
        this->kod_parser_->post_bpejCodeAttrType ();
        this->kod ();
      }

      return true;
    }

    return false;
  }

  // pa2_pskel
  //

  void pa2_pskel::
  area ()
  {
  }

  void pa2_pskel::
  bpej ()
  {
  }

  void pa2_pskel::
  brem ()
  {
  }

  void pa2_pskel::
  ochr ()
  {
  }

  void pa2_pskel::
  por ()
  {
  }

  void pa2_pskel::
  id ()
  {
  }

  void pa2_pskel::
  kcpp ()
  {
  }

  void pa2_pskel::
  pcpp ()
  {
  }

  void pa2_pskel::
  dcpp ()
  {
  }

  void pa2_pskel::
  kcp ()
  {
  }

  void pa2_pskel::
  pcp ()
  {
  }

  void pa2_pskel::
  dcp ()
  {
  }

  void pa2_pskel::
  kk ()
  {
  }

  void pa2_pskel::
  vym ()
  {
  }

  void pa2_pskel::
  vzd ()
  {
  }

  void pa2_pskel::
  dp ()
  {
  }

  void pa2_pskel::
  zv ()
  {
  }

  void pa2_pskel::
  res ()
  {
  }

  void pa2_pskel::
  poz ()
  {
  }

  void pa2_pskel::
  bu_id ()
  {
  }

  void pa2_pskel::
  cir ()
  {
  }

  void pa2_pskel::
  ps_id ()
  {
  }

  void pa2_pskel::
  souc ()
  {
  }

  void pa2_pskel::
  post_pa2 ()
  {
  }

  bool pa2_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "area" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->area_parser_;

      if (this->area_parser_)
        this->area_parser_->pre ();

      return true;
    }

    if (n == "bpej" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->bpej_parser_;

      if (this->bpej_parser_)
        this->bpej_parser_->pre ();

      return true;
    }

    if (n == "brem" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->brem_parser_;

      if (this->brem_parser_)
        this->brem_parser_->pre ();

      return true;
    }

    if (n == "ochr" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->ochr_parser_;

      if (this->ochr_parser_)
        this->ochr_parser_->pre ();

      return true;
    }

    if (n == "por" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->por_parser_;

      if (this->por_parser_)
        this->por_parser_->pre ();

      return true;
    }

    return false;
  }

  bool pa2_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "area" && ns.empty ())
    {
      if (this->area_parser_)
      {
        this->area_parser_->post_areaType ();
        this->area ();
      }

      return true;
    }

    if (n == "bpej" && ns.empty ())
    {
      if (this->bpej_parser_)
      {
        this->bpej_parser_->post_bpejCollectionType ();
        this->bpej ();
      }

      return true;
    }

    if (n == "brem" && ns.empty ())
    {
      if (this->brem_parser_)
      {
        this->brem_parser_->post_bremCollectionType ();
        this->brem ();
      }

      return true;
    }

    if (n == "ochr" && ns.empty ())
    {
      if (this->ochr_parser_)
      {
        this->ochr_parser_->post_ochrType ();
        this->ochr ();
      }

      return true;
    }

    if (n == "por" && ns.empty ())
    {
      if (this->por_parser_)
      {
        this->por_parser_->post_porCollectionType ();
        this->por ();
      }

      return true;
    }

    return false;
  }

  bool pa2_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
      return true;

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();
        this->id_parser_->_pre_impl ();
        this->id_parser_->_characters (v);
        this->id_parser_->_post_impl ();
        this->id_parser_->post_parcelIdAttrType ();
        this->id ();
      }

      return true;
    }

    if (n == "kcpp" && ns.empty ())
    {
      if (this->kcpp_parser_)
      {
        this->kcpp_parser_->pre ();
        this->kcpp_parser_->_pre_impl ();
        this->kcpp_parser_->_characters (v);
        this->kcpp_parser_->_post_impl ();
        this->kcpp_parser_->post_parcelNumberAttrType ();
        this->kcpp ();
      }

      return true;
    }

    if (n == "pcpp" && ns.empty ())
    {
      if (this->pcpp_parser_)
      {
        this->pcpp_parser_->pre ();
        this->pcpp_parser_->_pre_impl ();
        this->pcpp_parser_->_characters (v);
        this->pcpp_parser_->_post_impl ();
        this->pcpp_parser_->post_poddeleniNumberAttrType ();
        this->pcpp ();
      }

      return true;
    }

    if (n == "dcpp" && ns.empty ())
    {
      if (this->dcpp_parser_)
      {
        this->dcpp_parser_->pre ();
        this->dcpp_parser_->_pre_impl ();
        this->dcpp_parser_->_characters (v);
        this->dcpp_parser_->_post_impl ();
        this->dcpp_parser_->post_druhCislovaniNumberAttrType ();
        this->dcpp ();
      }

      return true;
    }

    if (n == "kcp" && ns.empty ())
    {
      if (this->kcp_parser_)
      {
        this->kcp_parser_->pre ();
        this->kcp_parser_->_pre_impl ();
        this->kcp_parser_->_characters (v);
        this->kcp_parser_->_post_impl ();
        this->kcp_parser_->post_parcelNumberAttrType ();
        this->kcp ();
      }

      return true;
    }

    if (n == "pcp" && ns.empty ())
    {
      if (this->pcp_parser_)
      {
        this->pcp_parser_->pre ();
        this->pcp_parser_->_pre_impl ();
        this->pcp_parser_->_characters (v);
        this->pcp_parser_->_post_impl ();
        this->pcp_parser_->post_poddeleniNumberAttrType ();
        this->pcp ();
      }

      return true;
    }

    if (n == "dcp" && ns.empty ())
    {
      if (this->dcp_parser_)
      {
        this->dcp_parser_->pre ();
        this->dcp_parser_->_pre_impl ();
        this->dcp_parser_->_characters (v);
        this->dcp_parser_->_post_impl ();
        this->dcp_parser_->post_druhCislovaniNumberAttrType ();
        this->dcp ();
      }

      return true;
    }

    if (n == "kk" && ns.empty ())
    {
      if (this->kk_parser_)
      {
        this->kk_parser_->pre ();
        this->kk_parser_->_pre_impl ();
        this->kk_parser_->_characters (v);
        this->kk_parser_->_post_impl ();
        this->kk_parser_->post_cadasterCodeType ();
        this->kk ();
      }

      return true;
    }

    if (n == "vym" && ns.empty ())
    {
      if (this->vym_parser_)
      {
        this->vym_parser_->pre ();
        this->vym_parser_->_pre_impl ();
        this->vym_parser_->_characters (v);
        this->vym_parser_->_post_impl ();
        this->vym_parser_->post_areaAttrType ();
        this->vym ();
      }

      return true;
    }

    if (n == "vzd" && ns.empty ())
    {
      if (this->vzd_parser_)
      {
        this->vzd_parser_->pre ();
        this->vzd_parser_->_pre_impl ();
        this->vzd_parser_->_characters (v);
        this->vzd_parser_->_post_impl ();
        this->vzd_parser_->post_distanceType ();
        this->vzd ();
      }

      return true;
    }

    if (n == "dp" && ns.empty ())
    {
      if (this->dp_parser_)
      {
        this->dp_parser_->pre ();
        this->dp_parser_->_pre_impl ();
        this->dp_parser_->_characters (v);
        this->dp_parser_->_post_impl ();
        this->dp_parser_->post_kindOfAreaAttrType ();
        this->dp ();
      }

      return true;
    }

    if (n == "zv" && ns.empty ())
    {
      if (this->zv_parser_)
      {
        this->zv_parser_->pre ();
        this->zv_parser_->_pre_impl ();
        this->zv_parser_->_characters (v);
        this->zv_parser_->_post_impl ();
        this->zv_parser_->post_kindOfUseAttrType ();
        this->zv ();
      }

      return true;
    }

    if (n == "res" && ns.empty ())
    {
      if (this->res_parser_)
      {
        this->res_parser_->pre ();
        this->res_parser_->_pre_impl ();
        this->res_parser_->_characters (v);
        this->res_parser_->_post_impl ();
        this->res_parser_->post_resAttrType ();
        this->res ();
      }

      return true;
    }

    if (n == "poz" && ns.empty ())
    {
      if (this->poz_parser_)
      {
        this->poz_parser_->pre ();
        this->poz_parser_->_pre_impl ();
        this->poz_parser_->_characters (v);
        this->poz_parser_->_post_impl ();
        this->poz_parser_->post_noteAttrType ();
        this->poz ();
      }

      return true;
    }

    if (n == "bu_id" && ns.empty ())
    {
      if (this->bu_id_parser_)
      {
        this->bu_id_parser_->pre ();
        this->bu_id_parser_->_pre_impl ();
        this->bu_id_parser_->_characters (v);
        this->bu_id_parser_->_post_impl ();
        this->bu_id_parser_->post_basicStringIdAttrType ();
        this->bu_id ();
      }

      return true;
    }

    if (n == "cir" && ns.empty ())
    {
      if (this->cir_parser_)
      {
        this->cir_parser_->pre ();
        this->cir_parser_->_pre_impl ();
        this->cir_parser_->_characters (v);
        this->cir_parser_->_post_impl ();
        this->cir_parser_->post_cirAttrType ();
        this->cir ();
      }

      return true;
    }

    if (n == "ps_id" && ns.empty ())
    {
      if (this->ps_id_parser_)
      {
        this->ps_id_parser_->pre ();
        this->ps_id_parser_->_pre_impl ();
        this->ps_id_parser_->_characters (v);
        this->ps_id_parser_->_post_impl ();
        this->ps_id_parser_->post_basicStringIdAttrType ();
        this->ps_id ();
      }

      return true;
    }

    if (n == "souc" && ns.empty ())
    {
      if (this->souc_parser_)
      {
        this->souc_parser_->pre ();
        this->souc_parser_->_pre_impl ();
        this->souc_parser_->_characters (v);
        this->souc_parser_->_post_impl ();
        this->souc_parser_->post_soucAttrType ();
        this->souc ();
      }

      return true;
    }

    return false;
  }

  // pa3_pskel
  //

  void pa3_pskel::
  gpar ()
  {
  }

  void pa3_pskel::
  bpej ()
  {
  }

  void pa3_pskel::
  por ()
  {
  }

  void pa3_pskel::
  parid ()
  {
  }

  void pa3_pskel::
  vymo ()
  {
  }

  void pa3_pskel::
  vzd ()
  {
  }

  void pa3_pskel::
  vymg ()
  {
  }

  void pa3_pskel::
  poz ()
  {
  }

  void pa3_pskel::
  cir ()
  {
  }

  void pa3_pskel::
  post_pa3 ()
  {
  }

  bool pa3_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "gpar" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->gpar_parser_;

      if (this->gpar_parser_)
        this->gpar_parser_->pre ();

      return true;
    }

    if (n == "bpej" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->bpej_parser_;

      if (this->bpej_parser_)
        this->bpej_parser_->pre ();

      return true;
    }

    if (n == "por" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->por_parser_;

      if (this->por_parser_)
        this->por_parser_->pre ();

      return true;
    }

    return false;
  }

  bool pa3_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "gpar" && ns.empty ())
    {
      if (this->gpar_parser_)
      {
        this->gpar_parser_->post_gparType ();
        this->gpar ();
      }

      return true;
    }

    if (n == "bpej" && ns.empty ())
    {
      if (this->bpej_parser_)
      {
        this->bpej_parser_->post_claimBpejCollectionType ();
        this->bpej ();
      }

      return true;
    }

    if (n == "por" && ns.empty ())
    {
      if (this->por_parser_)
      {
        this->por_parser_->post_porCollectionType ();
        this->por ();
      }

      return true;
    }

    return false;
  }

  bool pa3_pskel::
  _attribute_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n,
                   const ::xml_schema::ro_string& v)
  {
    if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
      return true;

    if (n == "parid" && ns.empty ())
    {
      if (this->parid_parser_)
      {
        this->parid_parser_->pre ();
        this->parid_parser_->_pre_impl ();
        this->parid_parser_->_characters (v);
        this->parid_parser_->_post_impl ();
        this->parid_parser_->post_parcelIdAttrType ();
        this->parid ();
      }

      return true;
    }

    if (n == "vymo" && ns.empty ())
    {
      if (this->vymo_parser_)
      {
        this->vymo_parser_->pre ();
        this->vymo_parser_->_pre_impl ();
        this->vymo_parser_->_characters (v);
        this->vymo_parser_->_post_impl ();
        this->vymo_parser_->post_areaAttrType ();
        this->vymo ();
      }

      return true;
    }

    if (n == "vzd" && ns.empty ())
    {
      if (this->vzd_parser_)
      {
        this->vzd_parser_->pre ();
        this->vzd_parser_->_pre_impl ();
        this->vzd_parser_->_characters (v);
        this->vzd_parser_->_post_impl ();
        this->vzd_parser_->post_distanceType ();
        this->vzd ();
      }

      return true;
    }

    if (n == "vymg" && ns.empty ())
    {
      if (this->vymg_parser_)
      {
        this->vymg_parser_->pre ();
        this->vymg_parser_->_pre_impl ();
        this->vymg_parser_->_characters (v);
        this->vymg_parser_->_post_impl ();
        this->vymg_parser_->post_areaAttrType ();
        this->vymg ();
      }

      return true;
    }

    if (n == "poz" && ns.empty ())
    {
      if (this->poz_parser_)
      {
        this->poz_parser_->pre ();
        this->poz_parser_->_pre_impl ();
        this->poz_parser_->_characters (v);
        this->poz_parser_->_post_impl ();
        this->poz_parser_->post_noteAttrType ();
        this->poz ();
      }

      return true;
    }

    if (n == "cir" && ns.empty ())
    {
      if (this->cir_parser_)
      {
        this->cir_parser_->pre ();
        this->cir_parser_->_pre_impl ();
        this->cir_parser_->_characters (v);
        this->cir_parser_->_post_impl ();
        this->cir_parser_->post_cirAttrType ();
        this->cir ();
      }

      return true;
    }

    return false;
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

